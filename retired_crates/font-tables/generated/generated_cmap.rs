// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use font_types::*;

/// [cmap](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#overview)
pub struct Cmap<'a> {
    version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    num_tables: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    encoding_records: zerocopy::LayoutVerified<&'a [u8], [EncodingRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Cmap<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (num_tables, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_tables = num_tables.get();
        let (encoding_records, bytes) =
            zerocopy::LayoutVerified::<_, [EncodingRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_tables as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap {
            version,
            num_tables,
            encoding_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Cmap<'a> {
    /// Table version number (0).
    pub fn version(&self) -> u16 {
        self.version.get()
    }

    /// Number of encoding tables that follow.
    pub fn num_tables(&self) -> u16 {
        self.num_tables.get()
    }

    pub fn encoding_records(&self) -> &[EncodingRecord] {
        &self.encoding_records
    }
}

impl<'a> font_types::OffsetHost<'a> for Cmap<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Encoding Record](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#encoding-records-and-encodings)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct EncodingRecord {
    /// Platform ID.
    pub platform_id: BigEndian<u16>,
    /// Platform-specific encoding ID.
    pub encoding_id: BigEndian<u16>,
    /// Byte offset from beginning of table to the subtable for this
    /// encoding.
    pub subtable_offset: BigEndian<Offset32>,
}

impl EncodingRecord {
    /// Platform ID.
    pub fn platform_id(&self) -> u16 {
        self.platform_id.get()
    }

    /// Platform-specific encoding ID.
    pub fn encoding_id(&self) -> u16 {
        self.encoding_id.get()
    }

    /// Byte offset from beginning of table to the subtable for this
    /// encoding.
    pub fn subtable_offset(&self) -> Offset32 {
        self.subtable_offset.get()
    }
}

/// <https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#platform-ids>
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum PlatformId {
    Unicode = 0,
    Macintosh = 1,
    ISO = 2,
    Windows = 3,
    Custom = 4,
    Unknown,
}

impl PlatformId {
    #[doc = r" Create from a raw scalar."]
    #[doc = r""]
    #[doc = r" This will never fail; unknown values will be mapped to the `Unknown` variant"]
    pub fn new(raw: u16) -> Self {
        match raw {
            0 => Self::Unicode,
            1 => Self::Macintosh,
            2 => Self::ISO,
            3 => Self::Windows,
            4 => Self::Custom,
            _ => Self::Unknown,
        }
    }
}

/// The different cmap subtable formats.
pub enum CmapSubtable<'a> {
    Format0(Cmap0<'a>),
    Format2(Cmap2<'a>),
    Format4(Cmap4<'a>),
    Format6(Cmap6<'a>),
    Format8(Cmap8<'a>),
    Format10(Cmap10<'a>),
    Format12(Cmap12<'a>),
    Format13(Cmap13<'a>),
    Format14(Cmap14<'a>),
}

impl<'a> font_types::FontRead<'a> for CmapSubtable<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            0 => Some(Self::Format0(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            4 => Some(Self::Format4(font_types::FontRead::read(bytes)?)),
            6 => Some(Self::Format6(font_types::FontRead::read(bytes)?)),
            8 => Some(Self::Format8(font_types::FontRead::read(bytes)?)),
            10 => Some(Self::Format10(font_types::FontRead::read(bytes)?)),
            12 => Some(Self::Format12(font_types::FontRead::read(bytes)?)),
            13 => Some(Self::Format13(font_types::FontRead::read(bytes)?)),
            14 => Some(Self::Format14(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(CmapSubtable)
                    );
                }
                None
            }
        }
    }
}

/// [cmap Format 0](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-0-byte-encoding-table): Byte encoding table
pub struct Cmap0<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_id_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u8>]>,
}

impl<'a> font_types::FontRead<'a> for Cmap0<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_id_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u8>]>::new_slice_unaligned_from_prefix(
                bytes,
                256 as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap0 {
            format,
            length,
            language,
            glyph_id_array,
        };
        Some(result)
    }
}

impl<'a> Cmap0<'a> {
    /// Format number is set to 0.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// This is the length in bytes of the subtable.
    pub fn length(&self) -> u16 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u16 {
        self.language.get()
    }

    /// An array that maps character codes to glyph index values.
    pub fn glyph_id_array(&self) -> &[BigEndian<u8>] {
        &self.glyph_id_array
    }
}

/// [cmap Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-2-high-byte-mapping-through-table): High-byte mapping through table
pub struct Cmap2<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    sub_header_keys: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Cmap2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (sub_header_keys, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                256 as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap2 {
            format,
            length,
            language,
            sub_header_keys,
        };
        Some(result)
    }
}

impl<'a> Cmap2<'a> {
    /// Format number is set to 2.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// This is the length in bytes of the subtable.
    pub fn length(&self) -> u16 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u16 {
        self.language.get()
    }

    /// Array that maps high bytes to subHeaders: value is subHeader
    /// index × 8.
    pub fn sub_header_keys(&self) -> &[BigEndian<u16>] {
        &self.sub_header_keys
    }
}

/// Part of [Cmap2]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct SubHeader {
    /// First valid low byte for this SubHeader.
    pub first_code: BigEndian<u16>,
    /// Number of valid low bytes for this SubHeader.
    pub entry_count: BigEndian<u16>,
    /// See text below.
    pub id_delta: BigEndian<i16>,
    /// See text below.
    pub id_range_offset: BigEndian<u16>,
}

impl SubHeader {
    /// First valid low byte for this SubHeader.
    pub fn first_code(&self) -> u16 {
        self.first_code.get()
    }

    /// Number of valid low bytes for this SubHeader.
    pub fn entry_count(&self) -> u16 {
        self.entry_count.get()
    }

    /// See text below.
    pub fn id_delta(&self) -> i16 {
        self.id_delta.get()
    }

    /// See text below.
    pub fn id_range_offset(&self) -> u16 {
        self.id_range_offset.get()
    }
}

/// [cmap Format 4](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-4-segment-mapping-to-delta-values): Segment mapping to delta values
pub struct Cmap4<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seg_count_x2: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    search_range: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    entry_selector: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    range_shift: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    end_code: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    #[allow(dead_code)]
    reserved_pad: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    start_code: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    id_delta: zerocopy::LayoutVerified<&'a [u8], [BigEndian<i16>]>,
    id_range_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    glyph_id_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Cmap4<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (seg_count_x2, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seg_count_x2 = seg_count_x2.get();
        let (search_range, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (entry_selector, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (range_shift, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (end_code, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                div_by_two(__resolved_seg_count_x2) as usize,
            )?;
        let (reserved_pad, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (start_code, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                div_by_two(__resolved_seg_count_x2) as usize,
            )?;
        let (id_delta, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<i16>]>::new_slice_unaligned_from_prefix(
                bytes,
                div_by_two(__resolved_seg_count_x2) as usize,
            )?;
        let (id_range_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                div_by_two(__resolved_seg_count_x2) as usize,
            )?;
        let (glyph_id_array, bytes) = (
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned(bytes)?,
            0,
        );
        let _bytes = bytes;
        let result = Cmap4 {
            format,
            length,
            language,
            seg_count_x2,
            search_range,
            entry_selector,
            range_shift,
            end_code,
            reserved_pad,
            start_code,
            id_delta,
            id_range_offsets,
            glyph_id_array,
        };
        Some(result)
    }
}

impl<'a> Cmap4<'a> {
    /// Format number is set to 4.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// This is the length in bytes of the subtable.
    pub fn length(&self) -> u16 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u16 {
        self.language.get()
    }

    /// 2 × segCount.
    pub fn seg_count_x2(&self) -> u16 {
        self.seg_count_x2.get()
    }

    /// Maximum power of 2 less than or equal to segCount, times 2
    /// ((2**floor(log2(segCount))) * 2, where “**” is an
    /// exponentiation operator)
    pub fn search_range(&self) -> u16 {
        self.search_range.get()
    }

    /// Log2 of the maximum power of 2 less than or equal to numTables
    /// (log2(searchRange/2), which is equal to floor(log2(segCount)))
    pub fn entry_selector(&self) -> u16 {
        self.entry_selector.get()
    }

    /// segCount times 2, minus searchRange ((segCount * 2) -
    /// searchRange)
    pub fn range_shift(&self) -> u16 {
        self.range_shift.get()
    }

    /// End characterCode for each segment, last=0xFFFF.
    pub fn end_code(&self) -> &[BigEndian<u16>] {
        &self.end_code
    }

    /// Start character code for each segment.
    pub fn start_code(&self) -> &[BigEndian<u16>] {
        &self.start_code
    }

    /// Delta for all character codes in segment.
    pub fn id_delta(&self) -> &[BigEndian<i16>] {
        &self.id_delta
    }

    /// Offsets into glyphIdArray or 0
    pub fn id_range_offsets(&self) -> &[BigEndian<u16>] {
        &self.id_range_offsets
    }

    /// Glyph index array (arbitrary length)
    pub fn glyph_id_array(&self) -> &[BigEndian<u16>] {
        &self.glyph_id_array
    }
}

/// [cmap Format 6](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-6-trimmed-table-mapping): Trimmed table mapping
pub struct Cmap6<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    first_code: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    entry_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_id_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Cmap6<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (first_code, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (entry_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_entry_count = entry_count.get();
        let (glyph_id_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_entry_count as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap6 {
            format,
            length,
            language,
            first_code,
            entry_count,
            glyph_id_array,
        };
        Some(result)
    }
}

impl<'a> Cmap6<'a> {
    /// Format number is set to 6.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// This is the length in bytes of the subtable.
    pub fn length(&self) -> u16 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u16 {
        self.language.get()
    }

    /// First character code of subrange.
    pub fn first_code(&self) -> u16 {
        self.first_code.get()
    }

    /// Number of character codes in subrange.
    pub fn entry_count(&self) -> u16 {
        self.entry_count.get()
    }

    /// Array of glyph index values for character codes in the range.
    pub fn glyph_id_array(&self) -> &[BigEndian<u16>] {
        &self.glyph_id_array
    }
}

/// [cmap Format 8](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-8-mixed-16-bit-and-32-bit-coverage): mixed 16-bit and 32-bit coverage
pub struct Cmap8<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    #[allow(dead_code)]
    reserved: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    is32: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u8>]>,
    num_groups: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    groups: zerocopy::LayoutVerified<&'a [u8], [SequentialMapGroup]>,
}

impl<'a> font_types::FontRead<'a> for Cmap8<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (reserved, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (is32, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u8>]>::new_slice_unaligned_from_prefix(
                bytes,
                8192 as usize,
            )?;
        let (num_groups, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_groups = num_groups.get();
        let (groups, bytes) =
            zerocopy::LayoutVerified::<_, [SequentialMapGroup]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_groups as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap8 {
            format,
            reserved,
            length,
            language,
            is32,
            num_groups,
            groups,
        };
        Some(result)
    }
}

impl<'a> Cmap8<'a> {
    /// Subtable format; set to 8.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Byte length of this subtable (including the header)
    pub fn length(&self) -> u32 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u32 {
        self.language.get()
    }

    /// Tightly packed array of bits (8K bytes total) indicating
    /// whether the particular 16-bit (index) value is the start of a
    /// 32-bit character code
    pub fn is32(&self) -> &[BigEndian<u8>] {
        &self.is32
    }

    /// Number of groupings which follow
    pub fn num_groups(&self) -> u32 {
        self.num_groups.get()
    }

    /// Array of SequentialMapGroup records.
    pub fn groups(&self) -> &[SequentialMapGroup] {
        &self.groups
    }
}

/// Used in [Cmap8] and [Cmap12]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct SequentialMapGroup {
    /// First character code in this group; note that if this group is
    /// for one or more 16-bit character codes (which is determined
    /// from the is32 array), this 32-bit value will have the high
    /// 16-bits set to zero
    pub start_char_code: BigEndian<u32>,
    /// Last character code in this group; same condition as listed
    /// above for the startCharCode
    pub end_char_code: BigEndian<u32>,
    /// Glyph index corresponding to the starting character code
    pub start_glyph_id: BigEndian<u32>,
}

impl SequentialMapGroup {
    /// First character code in this group; note that if this group is
    /// for one or more 16-bit character codes (which is determined
    /// from the is32 array), this 32-bit value will have the high
    /// 16-bits set to zero
    pub fn start_char_code(&self) -> u32 {
        self.start_char_code.get()
    }

    /// Last character code in this group; same condition as listed
    /// above for the startCharCode
    pub fn end_char_code(&self) -> u32 {
        self.end_char_code.get()
    }

    /// Glyph index corresponding to the starting character code
    pub fn start_glyph_id(&self) -> u32 {
        self.start_glyph_id.get()
    }
}

/// [cmap Format 10](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-10-trimmed-array): Tr
pub struct Cmap10<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    #[allow(dead_code)]
    reserved: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    start_char_code: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    num_chars: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    glyph_id_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Cmap10<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (reserved, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (start_char_code, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (num_chars, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_id_array, bytes) = (
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned(bytes)?,
            0,
        );
        let _bytes = bytes;
        let result = Cmap10 {
            format,
            reserved,
            length,
            language,
            start_char_code,
            num_chars,
            glyph_id_array,
        };
        Some(result)
    }
}

impl<'a> Cmap10<'a> {
    /// Subtable format; set to 10.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Byte length of this subtable (including the header)
    pub fn length(&self) -> u32 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u32 {
        self.language.get()
    }

    /// First character code covered
    pub fn start_char_code(&self) -> u32 {
        self.start_char_code.get()
    }

    /// Number of character codes covered
    pub fn num_chars(&self) -> u32 {
        self.num_chars.get()
    }

    /// Array of glyph indices for the character codes covered
    pub fn glyph_id_array(&self) -> &[BigEndian<u16>] {
        &self.glyph_id_array
    }
}

/// [cmap Format 12](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-12-segmented-coverage): Segmented coverage
pub struct Cmap12<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    #[allow(dead_code)]
    reserved: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    num_groups: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    groups: zerocopy::LayoutVerified<&'a [u8], [SequentialMapGroup]>,
}

impl<'a> font_types::FontRead<'a> for Cmap12<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (reserved, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (num_groups, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_groups = num_groups.get();
        let (groups, bytes) =
            zerocopy::LayoutVerified::<_, [SequentialMapGroup]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_groups as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap12 {
            format,
            reserved,
            length,
            language,
            num_groups,
            groups,
        };
        Some(result)
    }
}

impl<'a> Cmap12<'a> {
    /// Subtable format; set to 12.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Byte length of this subtable (including the header)
    pub fn length(&self) -> u32 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u32 {
        self.language.get()
    }

    /// Number of groupings which follow
    pub fn num_groups(&self) -> u32 {
        self.num_groups.get()
    }

    /// Array of SequentialMapGroup records.
    pub fn groups(&self) -> &[SequentialMapGroup] {
        &self.groups
    }
}

/// [cmap Format 13](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-13-many-to-one-range-mappings): Many-to-one range mappings
pub struct Cmap13<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    #[allow(dead_code)]
    reserved: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    language: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    num_groups: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    groups: zerocopy::LayoutVerified<&'a [u8], [ConstantMapGroup]>,
}

impl<'a> font_types::FontRead<'a> for Cmap13<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (reserved, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (language, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (num_groups, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_groups = num_groups.get();
        let (groups, bytes) =
            zerocopy::LayoutVerified::<_, [ConstantMapGroup]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_groups as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap13 {
            format,
            reserved,
            length,
            language,
            num_groups,
            groups,
        };
        Some(result)
    }
}

impl<'a> Cmap13<'a> {
    /// Subtable format; set to 13.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Byte length of this subtable (including the header)
    pub fn length(&self) -> u32 {
        self.length.get()
    }

    /// For requirements on use of the language field, see “Use of
    /// the language field in 'cmap' subtables” in this document.
    pub fn language(&self) -> u32 {
        self.language.get()
    }

    /// Number of groupings which follow
    pub fn num_groups(&self) -> u32 {
        self.num_groups.get()
    }

    /// Array of ConstantMapGroup records.
    pub fn groups(&self) -> &[ConstantMapGroup] {
        &self.groups
    }
}

/// Part of [Cmap13]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ConstantMapGroup {
    /// First character code in this group
    pub start_char_code: BigEndian<u32>,
    /// Last character code in this group
    pub end_char_code: BigEndian<u32>,
    /// Glyph index to be used for all the characters in the group’s
    /// range.
    pub glyph_id: BigEndian<u32>,
}

impl ConstantMapGroup {
    /// First character code in this group
    pub fn start_char_code(&self) -> u32 {
        self.start_char_code.get()
    }

    /// Last character code in this group
    pub fn end_char_code(&self) -> u32 {
        self.end_char_code.get()
    }

    /// Glyph index to be used for all the characters in the group’s
    /// range.
    pub fn glyph_id(&self) -> u32 {
        self.glyph_id.get()
    }
}

/// [cmap Format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences): Unicode Variation Sequences
pub struct Cmap14<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    length: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    num_var_selector_records: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    var_selector: zerocopy::LayoutVerified<&'a [u8], [VariationSelector]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Cmap14<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (length, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let (num_var_selector_records, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_var_selector_records = num_var_selector_records.get();
        let (var_selector, bytes) =
            zerocopy::LayoutVerified::<_, [VariationSelector]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_var_selector_records as usize,
            )?;
        let _bytes = bytes;
        let result = Cmap14 {
            format,
            length,
            num_var_selector_records,
            var_selector,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Cmap14<'a> {
    /// Subtable format. Set to 14.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Byte length of this subtable (including this header)
    pub fn length(&self) -> u32 {
        self.length.get()
    }

    /// Number of variation Selector Records
    pub fn num_var_selector_records(&self) -> u32 {
        self.num_var_selector_records.get()
    }

    /// Array of VariationSelector records.
    pub fn var_selector(&self) -> &[VariationSelector] {
        &self.var_selector
    }
}

impl<'a> font_types::OffsetHost<'a> for Cmap14<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [Cmap14]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct VariationSelector {
    /// Variation selector
    pub var_selector: BigEndian<Uint24>,
    /// Offset from the start of the format 14 subtable to Default UVS
    /// Table. May be 0.
    pub default_uvs_offset: BigEndian<Offset32>,
    /// Offset from the start of the format 14 subtable to Non-Default
    /// UVS Table. May be 0.
    pub non_default_uvs_offset: BigEndian<Offset32>,
}

impl VariationSelector {
    /// Variation selector
    pub fn var_selector(&self) -> Uint24 {
        self.var_selector.get()
    }

    /// Offset from the start of the format 14 subtable to Default UVS
    /// Table. May be 0.
    pub fn default_uvs_offset(&self) -> Offset32 {
        self.default_uvs_offset.get()
    }

    /// Offset from the start of the format 14 subtable to Non-Default
    /// UVS Table. May be 0.
    pub fn non_default_uvs_offset(&self) -> Offset32 {
        self.non_default_uvs_offset.get()
    }
}

/// [Default UVS table](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#default-uvs-table)
pub struct DefaultUvs<'a> {
    num_unicode_value_ranges: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    ranges: zerocopy::LayoutVerified<&'a [u8], [UnicodeRange]>,
}

impl<'a> font_types::FontRead<'a> for DefaultUvs<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (num_unicode_value_ranges, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_num_unicode_value_ranges = num_unicode_value_ranges.get();
        let (ranges, bytes) =
            zerocopy::LayoutVerified::<_, [UnicodeRange]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_num_unicode_value_ranges as usize,
            )?;
        let _bytes = bytes;
        let result = DefaultUvs {
            num_unicode_value_ranges,
            ranges,
        };
        Some(result)
    }
}

impl<'a> DefaultUvs<'a> {
    /// Number of Unicode character ranges.
    pub fn num_unicode_value_ranges(&self) -> u32 {
        self.num_unicode_value_ranges.get()
    }

    /// Array of UnicodeRange records.
    pub fn ranges(&self) -> &[UnicodeRange] {
        &self.ranges
    }
}

/// Part of [Cmap14]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct UVSMapping {
    /// Base Unicode value of the UVS
    pub unicode_value: BigEndian<Uint24>,
    /// Glyph ID of the UVS
    pub glyph_id: BigEndian<u16>,
}

impl UVSMapping {
    /// Base Unicode value of the UVS
    pub fn unicode_value(&self) -> Uint24 {
        self.unicode_value.get()
    }

    /// Glyph ID of the UVS
    pub fn glyph_id(&self) -> u16 {
        self.glyph_id.get()
    }
}

/// Part of [Cmap14]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct UnicodeRange {
    /// First value in this range
    pub start_unicode_value: BigEndian<Uint24>,
    /// Number of additional values in this range
    pub additional_count: BigEndian<u8>,
}

impl UnicodeRange {
    /// First value in this range
    pub fn start_unicode_value(&self) -> Uint24 {
        self.start_unicode_value.get()
    }

    /// Number of additional values in this range
    pub fn additional_count(&self) -> u8 {
        self.additional_count.get()
    }
}

// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

//! [OpenType™ Layout Common Table Formats](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2)
use font_types::*;

/// [Script List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-list-table-and-script-record)
pub struct ScriptList<'a> {
    script_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_records: zerocopy::LayoutVerified<&'a [u8], [ScriptRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ScriptList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (script_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_script_count = script_count.get();
        let (script_records, bytes) =
            zerocopy::LayoutVerified::<_, [ScriptRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_script_count as usize,
            )?;
        let _bytes = bytes;
        let result = ScriptList {
            script_count,
            script_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ScriptList<'a> {
    /// Number of ScriptRecords
    pub fn script_count(&self) -> u16 {
        self.script_count.get()
    }

    /// Array of ScriptRecords, listed alphabetically by script tag
    pub fn script_records(&self) -> &[ScriptRecord] {
        &self.script_records
    }
}

impl<'a> font_types::OffsetHost<'a> for ScriptList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Script Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-list-table-and-script-record)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ScriptRecord {
    /// 4-byte script tag identifier
    pub script_tag: BigEndian<Tag>,
    /// Offset to Script table, from beginning of ScriptList
    pub script_offset: BigEndian<Offset16>,
}

impl ScriptRecord {
    /// 4-byte script tag identifier
    pub fn script_tag(&self) -> Tag {
        self.script_tag.get()
    }

    /// Offset to Script table, from beginning of ScriptList
    pub fn script_offset(&self) -> Offset16 {
        self.script_offset.get()
    }
}

/// [Script Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-table-and-language-system-record)
pub struct Script<'a> {
    default_lang_sys_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lang_sys_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lang_sys_records: zerocopy::LayoutVerified<&'a [u8], [LangSysRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Script<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (default_lang_sys_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lang_sys_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lang_sys_count = lang_sys_count.get();
        let (lang_sys_records, bytes) =
            zerocopy::LayoutVerified::<_, [LangSysRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lang_sys_count as usize,
            )?;
        let _bytes = bytes;
        let result = Script {
            default_lang_sys_offset,
            lang_sys_count,
            lang_sys_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Script<'a> {
    /// Offset to default LangSys table, from beginning of Script table
    /// — may be NULL
    pub fn default_lang_sys_offset(&self) -> Offset16 {
        self.default_lang_sys_offset.get()
    }

    /// Number of LangSysRecords for this script — excluding the
    /// default LangSys
    pub fn lang_sys_count(&self) -> u16 {
        self.lang_sys_count.get()
    }

    /// Array of LangSysRecords, listed alphabetically by LangSys tag
    pub fn lang_sys_records(&self) -> &[LangSysRecord] {
        &self.lang_sys_records
    }
}

impl<'a> font_types::OffsetHost<'a> for Script<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct LangSysRecord {
    /// 4-byte LangSysTag identifier
    pub lang_sys_tag: BigEndian<Tag>,
    /// Offset to LangSys table, from beginning of Script table
    pub lang_sys_offset: BigEndian<Offset16>,
}

impl LangSysRecord {
    /// 4-byte LangSysTag identifier
    pub fn lang_sys_tag(&self) -> Tag {
        self.lang_sys_tag.get()
    }

    /// Offset to LangSys table, from beginning of Script table
    pub fn lang_sys_offset(&self) -> Offset16 {
        self.lang_sys_offset.get()
    }
}

/// [Language System Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#language-system-table)
pub struct LangSys<'a> {
    #[allow(dead_code)]
    lookup_order_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    required_feature_index: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_index_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_indices: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for LangSys<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (lookup_order_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (required_feature_index, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_index_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_index_count = feature_index_count.get();
        let (feature_indices, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_feature_index_count as usize,
            )?;
        let _bytes = bytes;
        let result = LangSys {
            lookup_order_offset,
            required_feature_index,
            feature_index_count,
            feature_indices,
        };
        Some(result)
    }
}

impl<'a> LangSys<'a> {
    /// Index of a feature required for this language system; if no
    /// required features = 0xFFFF
    pub fn required_feature_index(&self) -> u16 {
        self.required_feature_index.get()
    }

    /// Number of feature index values for this language system —
    /// excludes the required feature
    pub fn feature_index_count(&self) -> u16 {
        self.feature_index_count.get()
    }

    /// Array of indices into the FeatureList, in arbitrary order
    pub fn feature_indices(&self) -> &[BigEndian<u16>] {
        &self.feature_indices
    }
}

/// [Feature List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-list-table)
pub struct FeatureList<'a> {
    feature_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_records: zerocopy::LayoutVerified<&'a [u8], [FeatureRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (feature_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_count = feature_count.get();
        let (feature_records, bytes) =
            zerocopy::LayoutVerified::<_, [FeatureRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_feature_count as usize,
            )?;
        let _bytes = bytes;
        let result = FeatureList {
            feature_count,
            feature_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureList<'a> {
    /// Number of FeatureRecords in this table
    pub fn feature_count(&self) -> u16 {
        self.feature_count.get()
    }

    /// Array of FeatureRecords — zero-based (first feature has
    /// FeatureIndex = 0), listed alphabetically by feature tag
    pub fn feature_records(&self) -> &[FeatureRecord] {
        &self.feature_records
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [FeatureList]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureRecord {
    /// 4-byte feature identification tag
    pub feature_tag: BigEndian<Tag>,
    /// Offset to Feature table, from beginning of FeatureList
    pub feature_offset: BigEndian<Offset16>,
}

impl FeatureRecord {
    /// 4-byte feature identification tag
    pub fn feature_tag(&self) -> Tag {
        self.feature_tag.get()
    }

    /// Offset to Feature table, from beginning of FeatureList
    pub fn feature_offset(&self) -> Offset16 {
        self.feature_offset.get()
    }
}

/// [Feature Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-table)
pub struct Feature<'a> {
    lookup_index_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_list_indices: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Feature<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (lookup_index_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookup_index_count = lookup_index_count.get();
        let (lookup_list_indices, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookup_index_count as usize,
            )?;
        let _bytes = bytes;
        let result = Feature {
            lookup_index_count,
            lookup_list_indices,
        };
        Some(result)
    }
}

impl<'a> Feature<'a> {
    /// Number of LookupList indices for this feature
    pub fn lookup_index_count(&self) -> u16 {
        self.lookup_index_count.get()
    }

    /// Array of indices into the LookupList — zero-based (first
    /// lookup is LookupListIndex = 0)
    pub fn lookup_list_indices(&self) -> &[BigEndian<u16>] {
        &self.lookup_list_indices
    }
}

/// [Lookup List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-list-table)
pub struct LookupList<'a> {
    lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for LookupList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookup_count = lookup_count.get();
        let (lookup_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = LookupList {
            lookup_count,
            lookup_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> LookupList<'a> {
    /// Number of lookups in this table
    pub fn lookup_count(&self) -> u16 {
        self.lookup_count.get()
    }

    /// Array of offsets to Lookup tables, from beginning of LookupList
    /// — zero based (first lookup is Lookup index = 0)
    pub fn lookup_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.lookup_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LookupList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Lookup Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-table)
pub struct Lookup<'a> {
    lookup_type: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_flag: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    sub_table_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    subtable_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    mark_filtering_set: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Lookup<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (lookup_type, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_flag, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (sub_table_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_sub_table_count = sub_table_count.get();
        let (subtable_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_sub_table_count as usize,
            )?;
        let (mark_filtering_set, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Lookup {
            lookup_type,
            lookup_flag,
            sub_table_count,
            subtable_offsets,
            mark_filtering_set,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Lookup<'a> {
    /// Different enumerations for GSUB and GPOS
    pub fn lookup_type(&self) -> u16 {
        self.lookup_type.get()
    }

    /// Lookup qualifiers
    pub fn lookup_flag(&self) -> u16 {
        self.lookup_flag.get()
    }

    /// Number of subtables for this lookup
    pub fn sub_table_count(&self) -> u16 {
        self.sub_table_count.get()
    }

    /// Array of offsets to lookup subtables, from beginning of Lookup
    /// table
    pub fn subtable_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.subtable_offsets
    }

    /// Index (base 0) into GDEF mark glyph sets structure. This field
    /// is only present if the USE_MARK_FILTERING_SET lookup flag is
    /// set.
    pub fn mark_filtering_set(&self) -> u16 {
        self.mark_filtering_set.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Lookup<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Coverage Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-1)
pub struct CoverageFormat1<'a> {
    coverage_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for CoverageFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (coverage_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (glyph_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let _bytes = bytes;
        let result = CoverageFormat1 {
            coverage_format,
            glyph_count,
            glyph_array,
        };
        Some(result)
    }
}

impl<'a> CoverageFormat1<'a> {
    /// Format identifier — format = 1
    pub fn coverage_format(&self) -> u16 {
        self.coverage_format.get()
    }

    /// Number of glyphs in the glyph array
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Array of glyph IDs — in numerical order
    pub fn glyph_array(&self) -> &[BigEndian<u16>] {
        &self.glyph_array
    }
}

/// [Coverage Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-2)
pub struct CoverageFormat2<'a> {
    coverage_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    range_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    range_records: zerocopy::LayoutVerified<&'a [u8], [RangeRecord]>,
}

impl<'a> font_types::FontRead<'a> for CoverageFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (coverage_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (range_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_range_count = range_count.get();
        let (range_records, bytes) =
            zerocopy::LayoutVerified::<_, [RangeRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_range_count as usize,
            )?;
        let _bytes = bytes;
        let result = CoverageFormat2 {
            coverage_format,
            range_count,
            range_records,
        };
        Some(result)
    }
}

impl<'a> CoverageFormat2<'a> {
    /// Format identifier — format = 2
    pub fn coverage_format(&self) -> u16 {
        self.coverage_format.get()
    }

    /// Number of RangeRecords
    pub fn range_count(&self) -> u16 {
        self.range_count.get()
    }

    /// Array of glyph ranges — ordered by startGlyphID.
    pub fn range_records(&self) -> &[RangeRecord] {
        &self.range_records
    }
}

/// Used in [CoverageFormat2]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct RangeRecord {
    /// First glyph ID in the range
    pub start_glyph_id: BigEndian<u16>,
    /// Last glyph ID in the range
    pub end_glyph_id: BigEndian<u16>,
    /// Coverage Index of first glyph ID in range
    pub start_coverage_index: BigEndian<u16>,
}

impl RangeRecord {
    /// First glyph ID in the range
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Last glyph ID in the range
    pub fn end_glyph_id(&self) -> u16 {
        self.end_glyph_id.get()
    }

    /// Coverage Index of first glyph ID in range
    pub fn start_coverage_index(&self) -> u16 {
        self.start_coverage_index.get()
    }
}

/// [Coverage Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table)
pub enum CoverageTable<'a> {
    Format1(CoverageFormat1<'a>),
    Format2(CoverageFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for CoverageTable<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(CoverageTable)
                    );
                }
                None
            }
        }
    }
}

/// [Class Definition Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-1)
pub struct ClassDefFormat1<'a> {
    class_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    start_glyph_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_value_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for ClassDefFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (class_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (start_glyph_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (class_value_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassDefFormat1 {
            class_format,
            start_glyph_id,
            glyph_count,
            class_value_array,
        };
        Some(result)
    }
}

impl<'a> ClassDefFormat1<'a> {
    /// Format identifier — format = 1
    pub fn class_format(&self) -> u16 {
        self.class_format.get()
    }

    /// First glyph ID of the classValueArray
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Size of the classValueArray
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Array of Class Values — one per glyph ID
    pub fn class_value_array(&self) -> &[BigEndian<u16>] {
        &self.class_value_array
    }
}

/// [Class Definition Table Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-2)
pub struct ClassDefFormat2<'a> {
    class_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_range_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_range_records: zerocopy::LayoutVerified<&'a [u8], [ClassRangeRecord]>,
}

impl<'a> font_types::FontRead<'a> for ClassDefFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (class_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (class_range_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_range_count = class_range_count.get();
        let (class_range_records, bytes) =
            zerocopy::LayoutVerified::<_, [ClassRangeRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_range_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassDefFormat2 {
            class_format,
            class_range_count,
            class_range_records,
        };
        Some(result)
    }
}

impl<'a> ClassDefFormat2<'a> {
    /// Format identifier — format = 2
    pub fn class_format(&self) -> u16 {
        self.class_format.get()
    }

    /// Number of ClassRangeRecords
    pub fn class_range_count(&self) -> u16 {
        self.class_range_count.get()
    }

    /// Array of ClassRangeRecords — ordered by startGlyphID
    pub fn class_range_records(&self) -> &[ClassRangeRecord] {
        &self.class_range_records
    }
}

/// Used in [ClassDefFormat2]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ClassRangeRecord {
    /// First glyph ID in the range
    pub start_glyph_id: BigEndian<u16>,
    /// Last glyph ID in the range
    pub end_glyph_id: BigEndian<u16>,
    /// Applied to all glyphs in the range
    pub class: BigEndian<u16>,
}

impl ClassRangeRecord {
    /// First glyph ID in the range
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Last glyph ID in the range
    pub fn end_glyph_id(&self) -> u16 {
        self.end_glyph_id.get()
    }

    /// Applied to all glyphs in the range
    pub fn class(&self) -> u16 {
        self.class.get()
    }
}

pub enum ClassDef<'a> {
    Format1(ClassDefFormat1<'a>),
    Format2(ClassDefFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for ClassDef<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(ClassDef)
                    );
                }
                None
            }
        }
    }
}

/// [Sequence Lookup Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-lookup-record)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct SequenceLookupRecord {
    /// Index (zero-based) into the input glyph sequence
    pub sequence_index: BigEndian<u16>,
    /// Index (zero-based) into the LookupList
    pub lookup_list_index: BigEndian<u16>,
}

impl SequenceLookupRecord {
    /// Index (zero-based) into the input glyph sequence
    pub fn sequence_index(&self) -> u16 {
        self.sequence_index.get()
    }

    /// Index (zero-based) into the LookupList
    pub fn lookup_list_index(&self) -> u16 {
        self.lookup_list_index.get()
    }
}

/// [Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-1-simple-glyph-contexts)
pub struct SequenceContextFormat1<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_rule_set_count = seq_rule_set_count.get();
        let (seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat1 {
            format,
            coverage_offset,
            seq_rule_set_count,
            seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// SequenceContextFormat1 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Number of SequenceRuleSet tables
    pub fn seq_rule_set_count(&self) -> u16 {
        self.seq_rule_set_count.get()
    }

    /// Array of offsets to SequenceRuleSet tables, from beginning of
    /// SequenceContextFormat1 table (offsets may be NULL)
    pub fn seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.seq_rule_set_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat1]
pub struct SequenceRuleSet<'a> {
    seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_rule_count = seq_rule_count.get();
        let (seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceRuleSet {
            seq_rule_count,
            seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceRuleSet<'a> {
    /// Number of SequenceRule tables
    pub fn seq_rule_count(&self) -> u16 {
        self.seq_rule_count.get()
    }

    /// Array of offsets to SequenceRule tables, from beginning of the
    /// SequenceRuleSet table
    pub fn seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.seq_rule_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat1]
pub struct SequenceRule<'a> {
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for SequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_glyph_count) as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceRule {
            glyph_count,
            seq_lookup_count,
            input_sequence,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> SequenceRule<'a> {
    /// Number of glyphs in the input glyph sequence
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of input glyph IDs—starting with the second glyph
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Array of Sequence lookup records
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-2-class-based-glyph-contexts)
pub struct SequenceContextFormat2<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_seq_rule_set_count = class_seq_rule_set_count.get();
        let (class_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat2 {
            format,
            coverage_offset,
            class_def_offset,
            class_seq_rule_set_count,
            class_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// SequenceContextFormat2 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Offset to ClassDef table, from beginning of
    /// SequenceContextFormat2 table
    pub fn class_def_offset(&self) -> Offset16 {
        self.class_def_offset.get()
    }

    /// Number of ClassSequenceRuleSet tables
    pub fn class_seq_rule_set_count(&self) -> u16 {
        self.class_seq_rule_set_count.get()
    }

    /// Array of offsets to ClassSequenceRuleSet tables, from beginning
    /// of SequenceContextFormat2 table (may be NULL)
    pub fn class_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.class_seq_rule_set_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat2]
pub struct ClassSequenceRuleSet<'a> {
    class_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ClassSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (class_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_seq_rule_count = class_seq_rule_count.get();
        let (class_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassSequenceRuleSet {
            class_seq_rule_count,
            class_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ClassSequenceRuleSet<'a> {
    /// Number of ClassSequenceRule tables
    pub fn class_seq_rule_count(&self) -> u16 {
        self.class_seq_rule_count.get()
    }

    /// Array of offsets to ClassSequenceRule tables, from beginning of
    /// ClassSequenceRuleSet table
    pub fn class_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.class_seq_rule_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ClassSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat2]
pub struct ClassSequenceRule<'a> {
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ClassSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_glyph_count) as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassSequenceRule {
            glyph_count,
            seq_lookup_count,
            input_sequence,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ClassSequenceRule<'a> {
    /// Number of glyphs to be matched
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Sequence of classes to be matched to the input glyph sequence,
    /// beginning with the second glyph position
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-3-coverage-based-glyph-contexts)
pub struct SequenceContextFormat3<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat3 {
            format,
            glyph_count,
            seq_lookup_count,
            coverage_offsets,
            seq_lookup_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat3<'a> {
    /// Format identifier: format = 3
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Number of glyphs in the input sequence
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of offsets to Coverage tables, from beginning of
    /// SequenceContextFormat3 subtable
    pub fn coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.coverage_offsets
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum SequenceContext<'a> {
    Format1(SequenceContextFormat1<'a>),
    Format2(SequenceContextFormat2<'a>),
    Format3(SequenceContextFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for SequenceContext<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(SequenceContext)
                    );
                }
                None
            }
        }
    }
}

/// [Chained Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-1-simple-glyph-contexts)
pub struct ChainedSequenceContextFormat1<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    chained_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (chained_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_seq_rule_set_count = chained_seq_rule_set_count.get();
        let (chained_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat1 {
            format,
            coverage_offset,
            chained_seq_rule_set_count,
            chained_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// ChainSequenceContextFormat1 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Number of ChainedSequenceRuleSet tables
    pub fn chained_seq_rule_set_count(&self) -> u16 {
        self.chained_seq_rule_set_count.get()
    }

    /// Array of offsets to ChainedSeqRuleSet tables, from beginning of
    /// ChainedSequenceContextFormat1 table (may be NULL)
    pub fn chained_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_seq_rule_set_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat1]
pub struct ChainedSequenceRuleSet<'a> {
    chained_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (chained_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_seq_rule_count = chained_seq_rule_count.get();
        let (chained_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceRuleSet {
            chained_seq_rule_count,
            chained_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceRuleSet<'a> {
    /// Number of ChainedSequenceRule tables
    pub fn chained_seq_rule_count(&self) -> u16 {
        self.chained_seq_rule_count.get()
    }

    /// Array of offsets to ChainedSequenceRule tables, from beginning
    /// of ChainedSequenceRuleSet table
    pub fn chained_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_seq_rule_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat1]
pub struct ChainedSequenceRule<'a> {
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_input_glyph_count) as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceRule {
            backtrack_glyph_count,
            backtrack_sequence,
            input_glyph_count,
            input_sequence,
            lookahead_glyph_count,
            lookahead_sequence,
            seq_lookup_count,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceRule<'a> {
    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of backtrack glyph IDs
    pub fn backtrack_sequence(&self) -> &[BigEndian<u16>] {
        &self.backtrack_sequence
    }

    /// Number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of input glyph IDs—start with second glyph
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of lookahead glyph IDs
    pub fn lookahead_sequence(&self) -> &[BigEndian<u16>] {
        &self.lookahead_sequence
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Chained Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-2-class-based-glyph-contexts)
pub struct ChainedSequenceContextFormat2<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    backtrack_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    input_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookahead_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    chained_class_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_class_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (backtrack_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (input_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookahead_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (chained_class_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_class_seq_rule_set_count = chained_class_seq_rule_set_count.get();
        let (chained_class_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_class_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat2 {
            format,
            coverage_offset,
            backtrack_class_def_offset,
            input_class_def_offset,
            lookahead_class_def_offset,
            chained_class_seq_rule_set_count,
            chained_class_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// ChainedSequenceContextFormat2 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Offset to ClassDef table containing backtrack sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn backtrack_class_def_offset(&self) -> Offset16 {
        self.backtrack_class_def_offset.get()
    }

    /// Offset to ClassDef table containing input sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn input_class_def_offset(&self) -> Offset16 {
        self.input_class_def_offset.get()
    }

    /// Offset to ClassDef table containing lookahead sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn lookahead_class_def_offset(&self) -> Offset16 {
        self.lookahead_class_def_offset.get()
    }

    /// Number of ChainedClassSequenceRuleSet tables
    pub fn chained_class_seq_rule_set_count(&self) -> u16 {
        self.chained_class_seq_rule_set_count.get()
    }

    /// Array of offsets to ChainedClassSequenceRuleSet tables, from
    /// beginning of ChainedSequenceContextFormat2 table (may be NULL)
    pub fn chained_class_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_class_seq_rule_set_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat2]
pub struct ChainedClassSequenceRuleSet<'a> {
    chained_class_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_class_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedClassSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (chained_class_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_class_seq_rule_count = chained_class_seq_rule_count.get();
        let (chained_class_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_class_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedClassSequenceRuleSet {
            chained_class_seq_rule_count,
            chained_class_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedClassSequenceRuleSet<'a> {
    /// Number of ChainedClassSequenceRule tables
    pub fn chained_class_seq_rule_count(&self) -> u16 {
        self.chained_class_seq_rule_count.get()
    }

    /// Array of offsets to ChainedClassSequenceRule tables, from
    /// beginning of ChainedClassSequenceRuleSet
    pub fn chained_class_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_class_seq_rule_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedClassSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat2]
pub struct ChainedClassSequenceRule<'a> {
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ChainedClassSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_input_glyph_count) as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedClassSequenceRule {
            backtrack_glyph_count,
            backtrack_sequence,
            input_glyph_count,
            input_sequence,
            lookahead_glyph_count,
            lookahead_sequence,
            seq_lookup_count,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ChainedClassSequenceRule<'a> {
    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of backtrack-sequence classes
    pub fn backtrack_sequence(&self) -> &[BigEndian<u16>] {
        &self.backtrack_sequence
    }

    /// Total number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of input sequence classes, beginning with the second
    /// glyph position
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of lookahead-sequence classes
    pub fn lookahead_sequence(&self) -> &[BigEndian<u16>] {
        &self.lookahead_sequence
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Chained Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-3-coverage-based-glyph-contexts)
pub struct ChainedSequenceContextFormat3<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_input_glyph_count as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat3 {
            format,
            backtrack_glyph_count,
            backtrack_coverage_offsets,
            input_glyph_count,
            input_coverage_offsets,
            lookahead_glyph_count,
            lookahead_coverage_offsets,
            seq_lookup_count,
            seq_lookup_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat3<'a> {
    /// Format identifier: format = 3
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the backtrack sequence
    pub fn backtrack_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.backtrack_coverage_offsets
    }

    /// Number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the input sequence
    pub fn input_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.input_coverage_offsets
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the lookahead sequence
    pub fn lookahead_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.lookahead_coverage_offsets
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum ChainedSequenceContext<'a> {
    Format1(ChainedSequenceContextFormat1<'a>),
    Format2(ChainedSequenceContextFormat2<'a>),
    Format3(ChainedSequenceContextFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContext<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(ChainedSequenceContext)
                    );
                }
                None
            }
        }
    }
}

/// [Device Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#device-and-variationindex-tables)
pub struct Device<'a> {
    start_size: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    end_size: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    delta_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    delta_value: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Device<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (start_size, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (end_size, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (delta_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (delta_value, bytes) = (
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned(bytes)?,
            0,
        );
        let _bytes = bytes;
        let result = Device {
            start_size,
            end_size,
            delta_format,
            delta_value,
        };
        Some(result)
    }
}

impl<'a> Device<'a> {
    /// Smallest size to correct, in ppem
    pub fn start_size(&self) -> u16 {
        self.start_size.get()
    }

    /// Largest size to correct, in ppem
    pub fn end_size(&self) -> u16 {
        self.end_size.get()
    }

    /// Format of deltaValue array data: 0x0001, 0x0002, or 0x0003
    pub fn delta_format(&self) -> u16 {
        self.delta_format.get()
    }

    /// Array of compressed data
    pub fn delta_value(&self) -> &[BigEndian<u16>] {
        &self.delta_value
    }
}

/// Variation index table
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct VariationIndex {
    /// A delta-set outer index — used to select an item variation
    /// data subtable within the item variation store.
    pub delta_set_outer_index: BigEndian<u16>,
    /// A delta-set inner index — used to select a delta-set row
    /// within an item variation data subtable.
    pub delta_set_inner_index: BigEndian<u16>,
    /// Format, = 0x8000
    pub delta_format: BigEndian<u16>,
}

impl VariationIndex {
    /// A delta-set outer index — used to select an item variation
    /// data subtable within the item variation store.
    pub fn delta_set_outer_index(&self) -> u16 {
        self.delta_set_outer_index.get()
    }

    /// A delta-set inner index — used to select a delta-set row
    /// within an item variation data subtable.
    pub fn delta_set_inner_index(&self) -> u16 {
        self.delta_set_inner_index.get()
    }

    /// Format, = 0x8000
    pub fn delta_format(&self) -> u16 {
        self.delta_format.get()
    }
}

/// [FeatureVariations Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#featurevariations-table)
pub struct FeatureVariations<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_variation_record_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    feature_variation_records: zerocopy::LayoutVerified<&'a [u8], [FeatureVariationRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureVariations<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_variation_record_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_variation_record_count = feature_variation_record_count.get();
        let (feature_variation_records, bytes) = zerocopy::LayoutVerified::<
            _,
            [FeatureVariationRecord],
        >::new_slice_unaligned_from_prefix(
            bytes,
            __resolved_feature_variation_record_count as usize,
        )?;
        let _bytes = bytes;
        let result = FeatureVariations {
            major_version,
            minor_version,
            feature_variation_record_count,
            feature_variation_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureVariations<'a> {
    /// Major version of the FeatureVariations table — set to 1.
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the FeatureVariations table — set to 0.
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Number of feature variation records.
    pub fn feature_variation_record_count(&self) -> u32 {
        self.feature_variation_record_count.get()
    }

    /// Array of feature variation records.
    pub fn feature_variation_records(&self) -> &[FeatureVariationRecord] {
        &self.feature_variation_records
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureVariations<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [FeatureVariations]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureVariationRecord {
    /// Offset to a condition set table, from beginning of
    /// FeatureVariations table.
    pub condition_set_offset: BigEndian<Offset32>,
    /// Offset to a feature table substitution table, from beginning of
    /// the FeatureVariations table.
    pub feature_table_substitution_offset: BigEndian<Offset32>,
}

impl FeatureVariationRecord {
    /// Offset to a condition set table, from beginning of
    /// FeatureVariations table.
    pub fn condition_set_offset(&self) -> Offset32 {
        self.condition_set_offset.get()
    }

    /// Offset to a feature table substitution table, from beginning of
    /// the FeatureVariations table.
    pub fn feature_table_substitution_offset(&self) -> Offset32 {
        self.feature_table_substitution_offset.get()
    }
}

/// [ConditionSet Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#conditionset-table)
pub struct ConditionSet<'a> {
    condition_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    condition_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset32>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ConditionSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (condition_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_condition_count = condition_count.get();
        let (condition_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset32>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_condition_count as usize,
            )?;
        let _bytes = bytes;
        let result = ConditionSet {
            condition_count,
            condition_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ConditionSet<'a> {
    /// Number of conditions for this condition set.
    pub fn condition_count(&self) -> u16 {
        self.condition_count.get()
    }

    /// Array of offsets to condition tables, from beginning of the
    /// ConditionSet table.
    pub fn condition_offsets(&self) -> &[BigEndian<Offset32>] {
        &self.condition_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for ConditionSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Condition Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#condition-table-format-1-font-variation-axis-range): Font Variation Axis Range
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ConditionFormat1 {
    /// Format, = 1
    pub format: BigEndian<u16>,
    /// Index (zero-based) for the variation axis within the 'fvar'
    /// table.
    pub axis_index: BigEndian<u16>,
    /// Minimum value of the font variation instances that satisfy this
    /// condition.
    pub filter_range_min_value: BigEndian<F2Dot14>,
    /// Maximum value of the font variation instances that satisfy this
    /// condition.
    pub filter_range_max_value: BigEndian<F2Dot14>,
}

impl ConditionFormat1 {
    /// Format, = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Index (zero-based) for the variation axis within the 'fvar'
    /// table.
    pub fn axis_index(&self) -> u16 {
        self.axis_index.get()
    }

    /// Minimum value of the font variation instances that satisfy this
    /// condition.
    pub fn filter_range_min_value(&self) -> F2Dot14 {
        self.filter_range_min_value.get()
    }

    /// Maximum value of the font variation instances that satisfy this
    /// condition.
    pub fn filter_range_max_value(&self) -> F2Dot14 {
        self.filter_range_max_value.get()
    }
}

/// [FeatureTableSubstitution Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#featuretablesubstitution-table)
pub struct FeatureTableSubstitution<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    substitution_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    substitutions: zerocopy::LayoutVerified<&'a [u8], [FeatureTableSubstitutionRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureTableSubstitution<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (substitution_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_substitution_count = substitution_count.get();
        let (substitutions , bytes) = zerocopy :: LayoutVerified :: < _ , [FeatureTableSubstitutionRecord] > :: new_slice_unaligned_from_prefix (bytes , __resolved_substitution_count as usize) ? ;
        let _bytes = bytes;
        let result = FeatureTableSubstitution {
            major_version,
            minor_version,
            substitution_count,
            substitutions,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureTableSubstitution<'a> {
    /// Major version of the feature table substitution table — set
    /// to 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the feature table substitution table — set
    /// to 0.
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Number of feature table substitution records.
    pub fn substitution_count(&self) -> u16 {
        self.substitution_count.get()
    }

    /// Array of feature table substitution records.
    pub fn substitutions(&self) -> &[FeatureTableSubstitutionRecord] {
        &self.substitutions
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureTableSubstitution<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Used in [FeatureTableSubstitution]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureTableSubstitutionRecord {
    /// The feature table index to match.
    pub feature_index: BigEndian<u16>,
    /// Offset to an alternate feature table, from start of the
    /// FeatureTableSubstitution table.
    pub alternate_feature_offset: BigEndian<Offset32>,
}

impl FeatureTableSubstitutionRecord {
    /// The feature table index to match.
    pub fn feature_index(&self) -> u16 {
        self.feature_index.get()
    }

    /// Offset to an alternate feature table, from start of the
    /// FeatureTableSubstitution table.
    pub fn alternate_feature_offset(&self) -> Offset32 {
        self.alternate_feature_offset.get()
    }
}

fn minus_one(inp: u16) -> usize {
    inp.saturating_sub(1) as usize
}

#[cfg(feature = "compile")]
pub mod compile {
    use crate::compile::*;
    use font_types::*;
    fn plus_one(inp: usize) -> u16 {
        inp.saturating_add(1).try_into().unwrap()
    }

    #[derive(Debug, PartialEq)]
    pub struct ScriptList {
        pub script_records: Vec<ScriptRecord>,
    }

    impl ToOwnedObj for super::ScriptList<'_> {
        type Owned = ScriptList;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ScriptList {
                script_records: self
                    .script_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ScriptList<'_> {}

    impl FontWrite for ScriptList {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.script_records.len())
                .unwrap()
                .write_into(writer);
            self.script_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ScriptRecord {
        pub script_tag: Tag,
        pub script_offset: OffsetMarker<Offset16, Script>,
    }

    impl ToOwnedObj for super::ScriptRecord {
        type Owned = ScriptRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ScriptRecord {
                script_tag: self.script_tag(),
                script_offset: OffsetMarker::new_maybe_null(
                    self.script_offset()
                        .read::<super::Script>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for ScriptRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.script_tag.write_into(writer);
            self.script_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Script {
        pub default_lang_sys_offset: OffsetMarker<Offset16, LangSys>,
        pub lang_sys_records: Vec<LangSysRecord>,
    }

    impl ToOwnedObj for super::Script<'_> {
        type Owned = Script;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Script {
                default_lang_sys_offset: OffsetMarker::new_maybe_null(
                    self.default_lang_sys_offset()
                        .read::<super::LangSys>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lang_sys_records: self
                    .lang_sys_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::Script<'_> {}

    impl FontWrite for Script {
        fn write_into(&self, writer: &mut TableWriter) {
            self.default_lang_sys_offset.write_into(writer);
            u16::try_from(self.lang_sys_records.len())
                .unwrap()
                .write_into(writer);
            self.lang_sys_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct LangSysRecord {
        pub lang_sys_tag: Tag,
        pub lang_sys_offset: OffsetMarker<Offset16, LangSys>,
    }

    impl ToOwnedObj for super::LangSysRecord {
        type Owned = LangSysRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(LangSysRecord {
                lang_sys_tag: self.lang_sys_tag(),
                lang_sys_offset: OffsetMarker::new_maybe_null(
                    self.lang_sys_offset()
                        .read::<super::LangSys>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for LangSysRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.lang_sys_tag.write_into(writer);
            self.lang_sys_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct LangSys {
        pub required_feature_index: u16,
        pub feature_indices: Vec<u16>,
    }

    impl ToOwnedObj for super::LangSys<'_> {
        type Owned = LangSys;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(LangSys {
                required_feature_index: self.required_feature_index(),
                feature_indices: self
                    .feature_indices()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for LangSys {
        fn write_into(&self, writer: &mut TableWriter) {
            let lookup_order_offset: OffsetMarker<Offset16, Box<dyn FontWrite>> =
                Default::default();
            lookup_order_offset.write_into(writer);
            self.required_feature_index.write_into(writer);
            u16::try_from(self.feature_indices.len())
                .unwrap()
                .write_into(writer);
            self.feature_indices.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureList {
        pub feature_records: Vec<FeatureRecord>,
    }

    impl ToOwnedObj for super::FeatureList<'_> {
        type Owned = FeatureList;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(FeatureList {
                feature_records: self
                    .feature_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::FeatureList<'_> {}

    impl FontWrite for FeatureList {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.feature_records.len())
                .unwrap()
                .write_into(writer);
            self.feature_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureRecord {
        pub feature_tag: Tag,
        pub feature_offset: OffsetMarker<Offset16, Feature>,
    }

    impl ToOwnedObj for super::FeatureRecord {
        type Owned = FeatureRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(FeatureRecord {
                feature_tag: self.feature_tag(),
                feature_offset: OffsetMarker::new_maybe_null(
                    self.feature_offset()
                        .read::<super::Feature>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for FeatureRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.feature_tag.write_into(writer);
            self.feature_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Feature {
        pub lookup_list_indices: Vec<u16>,
    }

    impl ToOwnedObj for super::Feature<'_> {
        type Owned = Feature;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(Feature {
                lookup_list_indices: self
                    .lookup_list_indices()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for Feature {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.lookup_list_indices.len())
                .unwrap()
                .write_into(writer);
            self.lookup_list_indices.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct CoverageFormat1 {
        pub glyph_array: Vec<u16>,
    }

    impl ToOwnedObj for super::CoverageFormat1<'_> {
        type Owned = CoverageFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(CoverageFormat1 {
                glyph_array: self
                    .glyph_array()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for CoverageFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let coverage_format: u16 = 1;
            coverage_format.write_into(writer);
            u16::try_from(self.glyph_array.len())
                .unwrap()
                .write_into(writer);
            self.glyph_array.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct CoverageFormat2 {
        pub range_records: Vec<RangeRecord>,
    }

    impl ToOwnedObj for super::CoverageFormat2<'_> {
        type Owned = CoverageFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(CoverageFormat2 {
                range_records: self
                    .range_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for CoverageFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            let coverage_format: u16 = 2;
            coverage_format.write_into(writer);
            u16::try_from(self.range_records.len())
                .unwrap()
                .write_into(writer);
            self.range_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct RangeRecord {
        pub start_glyph_id: u16,
        pub end_glyph_id: u16,
        pub start_coverage_index: u16,
    }

    impl ToOwnedObj for super::RangeRecord {
        type Owned = RangeRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(RangeRecord {
                start_glyph_id: self.start_glyph_id(),
                end_glyph_id: self.end_glyph_id(),
                start_coverage_index: self.start_coverage_index(),
            })
        }
    }

    impl FontWrite for RangeRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.start_glyph_id.write_into(writer);
            self.end_glyph_id.write_into(writer);
            self.start_coverage_index.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum CoverageTable {
        Format1(CoverageFormat1),
        Format2(CoverageFormat2),
    }

    impl ToOwnedObj for super::CoverageTable<'_> {
        type Owned = CoverageTable;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::CoverageTable::Format1(item) => {
                    CoverageTable::Format1(item.to_owned_obj(offset_data)?)
                }
                super::CoverageTable::Format2(item) => {
                    CoverageTable::Format2(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl FontWrite for CoverageTable {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ClassDefFormat1 {
        pub start_glyph_id: u16,
        pub class_value_array: Vec<u16>,
    }

    impl ToOwnedObj for super::ClassDefFormat1<'_> {
        type Owned = ClassDefFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ClassDefFormat1 {
                start_glyph_id: self.start_glyph_id(),
                class_value_array: self
                    .class_value_array()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ClassDefFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let class_format: u16 = 1;
            class_format.write_into(writer);
            self.start_glyph_id.write_into(writer);
            u16::try_from(self.class_value_array.len())
                .unwrap()
                .write_into(writer);
            self.class_value_array.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ClassDefFormat2 {
        pub class_range_records: Vec<ClassRangeRecord>,
    }

    impl ToOwnedObj for super::ClassDefFormat2<'_> {
        type Owned = ClassDefFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ClassDefFormat2 {
                class_range_records: self
                    .class_range_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ClassDefFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            let class_format: u16 = 2;
            class_format.write_into(writer);
            u16::try_from(self.class_range_records.len())
                .unwrap()
                .write_into(writer);
            self.class_range_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ClassRangeRecord {
        pub start_glyph_id: u16,
        pub end_glyph_id: u16,
        pub class: u16,
    }

    impl ToOwnedObj for super::ClassRangeRecord {
        type Owned = ClassRangeRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ClassRangeRecord {
                start_glyph_id: self.start_glyph_id(),
                end_glyph_id: self.end_glyph_id(),
                class: self.class(),
            })
        }
    }

    impl FontWrite for ClassRangeRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.start_glyph_id.write_into(writer);
            self.end_glyph_id.write_into(writer);
            self.class.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum ClassDef {
        Format1(ClassDefFormat1),
        Format2(ClassDefFormat2),
    }

    impl ToOwnedObj for super::ClassDef<'_> {
        type Owned = ClassDef;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::ClassDef::Format1(item) => {
                    ClassDef::Format1(item.to_owned_obj(offset_data)?)
                }
                super::ClassDef::Format2(item) => {
                    ClassDef::Format2(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl FontWrite for ClassDef {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceLookupRecord {
        pub sequence_index: u16,
        pub lookup_list_index: u16,
    }

    impl ToOwnedObj for super::SequenceLookupRecord {
        type Owned = SequenceLookupRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(SequenceLookupRecord {
                sequence_index: self.sequence_index(),
                lookup_list_index: self.lookup_list_index(),
            })
        }
    }

    impl FontWrite for SequenceLookupRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.sequence_index.write_into(writer);
            self.lookup_list_index.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceContextFormat1 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub seq_rule_set_offsets: Vec<OffsetMarker<Offset16, SequenceRuleSet>>,
    }

    impl ToOwnedObj for super::SequenceContextFormat1<'_> {
        type Owned = SequenceContextFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SequenceContextFormat1 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                seq_rule_set_offsets: self
                    .seq_rule_set_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::SequenceRuleSet>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::SequenceContextFormat1<'_> {}

    impl FontWrite for SequenceContextFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 1;
            format.write_into(writer);
            self.coverage_offset.write_into(writer);
            u16::try_from(self.seq_rule_set_offsets.len())
                .unwrap()
                .write_into(writer);
            self.seq_rule_set_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceRuleSet {
        pub seq_rule_offsets: Vec<OffsetMarker<Offset16, SequenceRule>>,
    }

    impl ToOwnedObj for super::SequenceRuleSet<'_> {
        type Owned = SequenceRuleSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SequenceRuleSet {
                seq_rule_offsets: self
                    .seq_rule_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::SequenceRule>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::SequenceRuleSet<'_> {}

    impl FontWrite for SequenceRuleSet {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.seq_rule_offsets.len())
                .unwrap()
                .write_into(writer);
            self.seq_rule_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceRule {
        pub input_sequence: Vec<u16>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::SequenceRule<'_> {
        type Owned = SequenceRule;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(SequenceRule {
                input_sequence: self
                    .input_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for SequenceRule {
        fn write_into(&self, writer: &mut TableWriter) {
            let glyph_count: u16 = plus_one(self.input_sequence.len());
            glyph_count.write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.input_sequence.write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceContextFormat2 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub class_def_offset: OffsetMarker<Offset16, ClassDef>,
        pub class_seq_rule_set_offsets: Vec<OffsetMarker<Offset16, ClassSequenceRuleSet>>,
    }

    impl ToOwnedObj for super::SequenceContextFormat2<'_> {
        type Owned = SequenceContextFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SequenceContextFormat2 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                class_def_offset: OffsetMarker::new_maybe_null(
                    self.class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                class_seq_rule_set_offsets: self
                    .class_seq_rule_set_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ClassSequenceRuleSet>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::SequenceContextFormat2<'_> {}

    impl FontWrite for SequenceContextFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 2;
            format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.class_def_offset.write_into(writer);
            u16::try_from(self.class_seq_rule_set_offsets.len())
                .unwrap()
                .write_into(writer);
            self.class_seq_rule_set_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ClassSequenceRuleSet {
        pub class_seq_rule_offsets: Vec<OffsetMarker<Offset16, ClassSequenceRule>>,
    }

    impl ToOwnedObj for super::ClassSequenceRuleSet<'_> {
        type Owned = ClassSequenceRuleSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ClassSequenceRuleSet {
                class_seq_rule_offsets: self
                    .class_seq_rule_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ClassSequenceRule>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ClassSequenceRuleSet<'_> {}

    impl FontWrite for ClassSequenceRuleSet {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.class_seq_rule_offsets.len())
                .unwrap()
                .write_into(writer);
            self.class_seq_rule_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ClassSequenceRule {
        pub input_sequence: Vec<u16>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::ClassSequenceRule<'_> {
        type Owned = ClassSequenceRule;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ClassSequenceRule {
                input_sequence: self
                    .input_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ClassSequenceRule {
        fn write_into(&self, writer: &mut TableWriter) {
            let glyph_count: u16 = plus_one(self.input_sequence.len());
            glyph_count.write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.input_sequence.write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SequenceContextFormat3 {
        pub coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::SequenceContextFormat3<'_> {
        type Owned = SequenceContextFormat3;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SequenceContextFormat3 {
                coverage_offsets: self
                    .coverage_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CoverageTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::SequenceContextFormat3<'_> {}

    impl FontWrite for SequenceContextFormat3 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 3;
            format.write_into(writer);
            u16::try_from(self.coverage_offsets.len())
                .unwrap()
                .write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.coverage_offsets.write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum SequenceContext {
        Format1(SequenceContextFormat1),
        Format2(SequenceContextFormat2),
        Format3(SequenceContextFormat3),
    }

    impl ToOwnedObj for super::SequenceContext<'_> {
        type Owned = SequenceContext;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::SequenceContext::Format1(item) => {
                    SequenceContext::Format1(item.to_owned_obj(offset_data)?)
                }
                super::SequenceContext::Format2(item) => {
                    SequenceContext::Format2(item.to_owned_obj(offset_data)?)
                }
                super::SequenceContext::Format3(item) => {
                    SequenceContext::Format3(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl ToOwnedTable for super::SequenceContext<'_> {}

    impl FontWrite for SequenceContext {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
                Self::Format3(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedSequenceContextFormat1 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub chained_seq_rule_set_offsets: Vec<OffsetMarker<Offset16, ChainedSequenceRuleSet>>,
    }

    impl ToOwnedObj for super::ChainedSequenceContextFormat1<'_> {
        type Owned = ChainedSequenceContextFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ChainedSequenceContextFormat1 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                chained_seq_rule_set_offsets: self
                    .chained_seq_rule_set_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ChainedSequenceRuleSet>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ChainedSequenceContextFormat1<'_> {}

    impl FontWrite for ChainedSequenceContextFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 1;
            format.write_into(writer);
            self.coverage_offset.write_into(writer);
            u16::try_from(self.chained_seq_rule_set_offsets.len())
                .unwrap()
                .write_into(writer);
            self.chained_seq_rule_set_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedSequenceRuleSet {
        pub chained_seq_rule_offsets: Vec<OffsetMarker<Offset16, ChainedSequenceRule>>,
    }

    impl ToOwnedObj for super::ChainedSequenceRuleSet<'_> {
        type Owned = ChainedSequenceRuleSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ChainedSequenceRuleSet {
                chained_seq_rule_offsets: self
                    .chained_seq_rule_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ChainedSequenceRule>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ChainedSequenceRuleSet<'_> {}

    impl FontWrite for ChainedSequenceRuleSet {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.chained_seq_rule_offsets.len())
                .unwrap()
                .write_into(writer);
            self.chained_seq_rule_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedSequenceRule {
        pub backtrack_sequence: Vec<u16>,
        pub input_sequence: Vec<u16>,
        pub lookahead_sequence: Vec<u16>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::ChainedSequenceRule<'_> {
        type Owned = ChainedSequenceRule;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ChainedSequenceRule {
                backtrack_sequence: self
                    .backtrack_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                input_sequence: self
                    .input_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                lookahead_sequence: self
                    .lookahead_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ChainedSequenceRule {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.backtrack_sequence.len())
                .unwrap()
                .write_into(writer);
            self.backtrack_sequence.write_into(writer);
            let input_glyph_count: u16 = plus_one(self.input_sequence.len());
            input_glyph_count.write_into(writer);
            self.input_sequence.write_into(writer);
            u16::try_from(self.lookahead_sequence.len())
                .unwrap()
                .write_into(writer);
            self.lookahead_sequence.write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedSequenceContextFormat2 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub backtrack_class_def_offset: OffsetMarker<Offset16, ClassDef>,
        pub input_class_def_offset: OffsetMarker<Offset16, ClassDef>,
        pub lookahead_class_def_offset: OffsetMarker<Offset16, ClassDef>,
        pub chained_class_seq_rule_set_offsets:
            Vec<OffsetMarker<Offset16, ChainedClassSequenceRuleSet>>,
    }

    impl ToOwnedObj for super::ChainedSequenceContextFormat2<'_> {
        type Owned = ChainedSequenceContextFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ChainedSequenceContextFormat2 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                backtrack_class_def_offset: OffsetMarker::new_maybe_null(
                    self.backtrack_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                input_class_def_offset: OffsetMarker::new_maybe_null(
                    self.input_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lookahead_class_def_offset: OffsetMarker::new_maybe_null(
                    self.lookahead_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                chained_class_seq_rule_set_offsets: self
                    .chained_class_seq_rule_set_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ChainedClassSequenceRuleSet>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ChainedSequenceContextFormat2<'_> {}

    impl FontWrite for ChainedSequenceContextFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 2;
            format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.backtrack_class_def_offset.write_into(writer);
            self.input_class_def_offset.write_into(writer);
            self.lookahead_class_def_offset.write_into(writer);
            u16::try_from(self.chained_class_seq_rule_set_offsets.len())
                .unwrap()
                .write_into(writer);
            self.chained_class_seq_rule_set_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedClassSequenceRuleSet {
        pub chained_class_seq_rule_offsets: Vec<OffsetMarker<Offset16, ChainedClassSequenceRule>>,
    }

    impl ToOwnedObj for super::ChainedClassSequenceRuleSet<'_> {
        type Owned = ChainedClassSequenceRuleSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ChainedClassSequenceRuleSet {
                chained_class_seq_rule_offsets: self
                    .chained_class_seq_rule_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ChainedClassSequenceRule>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ChainedClassSequenceRuleSet<'_> {}

    impl FontWrite for ChainedClassSequenceRuleSet {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.chained_class_seq_rule_offsets.len())
                .unwrap()
                .write_into(writer);
            self.chained_class_seq_rule_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedClassSequenceRule {
        pub backtrack_sequence: Vec<u16>,
        pub input_sequence: Vec<u16>,
        pub lookahead_sequence: Vec<u16>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::ChainedClassSequenceRule<'_> {
        type Owned = ChainedClassSequenceRule;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ChainedClassSequenceRule {
                backtrack_sequence: self
                    .backtrack_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                input_sequence: self
                    .input_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                lookahead_sequence: self
                    .lookahead_sequence()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ChainedClassSequenceRule {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.backtrack_sequence.len())
                .unwrap()
                .write_into(writer);
            self.backtrack_sequence.write_into(writer);
            let input_glyph_count: u16 = plus_one(self.input_sequence.len());
            input_glyph_count.write_into(writer);
            self.input_sequence.write_into(writer);
            u16::try_from(self.lookahead_sequence.len())
                .unwrap()
                .write_into(writer);
            self.lookahead_sequence.write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ChainedSequenceContextFormat3 {
        pub backtrack_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
        pub input_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
        pub lookahead_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
        pub seq_lookup_records: Vec<SequenceLookupRecord>,
    }

    impl ToOwnedObj for super::ChainedSequenceContextFormat3<'_> {
        type Owned = ChainedSequenceContextFormat3;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ChainedSequenceContextFormat3 {
                backtrack_coverage_offsets: self
                    .backtrack_coverage_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CoverageTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
                input_coverage_offsets: self
                    .input_coverage_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CoverageTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
                lookahead_coverage_offsets: self
                    .lookahead_coverage_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CoverageTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
                seq_lookup_records: self
                    .seq_lookup_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ChainedSequenceContextFormat3<'_> {}

    impl FontWrite for ChainedSequenceContextFormat3 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 3;
            format.write_into(writer);
            u16::try_from(self.backtrack_coverage_offsets.len())
                .unwrap()
                .write_into(writer);
            self.backtrack_coverage_offsets.write_into(writer);
            u16::try_from(self.input_coverage_offsets.len())
                .unwrap()
                .write_into(writer);
            self.input_coverage_offsets.write_into(writer);
            u16::try_from(self.lookahead_coverage_offsets.len())
                .unwrap()
                .write_into(writer);
            self.lookahead_coverage_offsets.write_into(writer);
            u16::try_from(self.seq_lookup_records.len())
                .unwrap()
                .write_into(writer);
            self.seq_lookup_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum ChainedSequenceContext {
        Format1(ChainedSequenceContextFormat1),
        Format2(ChainedSequenceContextFormat2),
        Format3(ChainedSequenceContextFormat3),
    }

    impl ToOwnedObj for super::ChainedSequenceContext<'_> {
        type Owned = ChainedSequenceContext;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::ChainedSequenceContext::Format1(item) => {
                    ChainedSequenceContext::Format1(item.to_owned_obj(offset_data)?)
                }
                super::ChainedSequenceContext::Format2(item) => {
                    ChainedSequenceContext::Format2(item.to_owned_obj(offset_data)?)
                }
                super::ChainedSequenceContext::Format3(item) => {
                    ChainedSequenceContext::Format3(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl ToOwnedTable for super::ChainedSequenceContext<'_> {}

    impl FontWrite for ChainedSequenceContext {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
                Self::Format3(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Device {
        pub start_size: u16,
        pub end_size: u16,
        pub delta_format: u16,
        pub delta_value: Vec<u16>,
    }

    impl ToOwnedObj for super::Device<'_> {
        type Owned = Device;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(Device {
                start_size: self.start_size(),
                end_size: self.end_size(),
                delta_format: self.delta_format(),
                delta_value: self
                    .delta_value()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for Device {
        fn write_into(&self, writer: &mut TableWriter) {
            self.start_size.write_into(writer);
            self.end_size.write_into(writer);
            self.delta_format.write_into(writer);
            self.delta_value.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct VariationIndex {
        pub delta_set_outer_index: u16,
        pub delta_set_inner_index: u16,
        pub delta_format: u16,
    }

    impl ToOwnedObj for super::VariationIndex {
        type Owned = VariationIndex;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(VariationIndex {
                delta_set_outer_index: self.delta_set_outer_index(),
                delta_set_inner_index: self.delta_set_inner_index(),
                delta_format: self.delta_format(),
            })
        }
    }

    impl FontWrite for VariationIndex {
        fn write_into(&self, writer: &mut TableWriter) {
            self.delta_set_outer_index.write_into(writer);
            self.delta_set_inner_index.write_into(writer);
            self.delta_format.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureVariations {
        pub feature_variation_records: Vec<FeatureVariationRecord>,
    }

    impl ToOwnedObj for super::FeatureVariations<'_> {
        type Owned = FeatureVariations;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(FeatureVariations {
                feature_variation_records: self
                    .feature_variation_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::FeatureVariations<'_> {}

    impl FontWrite for FeatureVariations {
        fn write_into(&self, writer: &mut TableWriter) {
            let major_version: u16 = 1;
            major_version.write_into(writer);
            let minor_version: u16 = 0;
            minor_version.write_into(writer);
            u32::try_from(self.feature_variation_records.len())
                .unwrap()
                .write_into(writer);
            self.feature_variation_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureVariationRecord {
        pub condition_set_offset: OffsetMarker<Offset32, ConditionSet>,
        pub feature_table_substitution_offset: OffsetMarker<Offset32, FeatureTableSubstitution>,
    }

    impl ToOwnedObj for super::FeatureVariationRecord {
        type Owned = FeatureVariationRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(FeatureVariationRecord {
                condition_set_offset: OffsetMarker::new_maybe_null(
                    self.condition_set_offset()
                        .read::<super::ConditionSet>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                feature_table_substitution_offset: OffsetMarker::new_maybe_null(
                    self.feature_table_substitution_offset()
                        .read::<super::FeatureTableSubstitution>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for FeatureVariationRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.condition_set_offset.write_into(writer);
            self.feature_table_substitution_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ConditionSet {
        pub condition_offsets: Vec<OffsetMarker<Offset32, ConditionFormat1>>,
    }

    impl ToOwnedObj for super::ConditionSet<'_> {
        type Owned = ConditionSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(ConditionSet {
                condition_offsets: self
                    .condition_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::ConditionFormat1>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::ConditionSet<'_> {}

    impl FontWrite for ConditionSet {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.condition_offsets.len())
                .unwrap()
                .write_into(writer);
            self.condition_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ConditionFormat1 {
        pub axis_index: u16,
        pub filter_range_min_value: F2Dot14,
        pub filter_range_max_value: F2Dot14,
    }

    impl ToOwnedObj for super::ConditionFormat1 {
        type Owned = ConditionFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ConditionFormat1 {
                axis_index: self.axis_index(),
                filter_range_min_value: self.filter_range_min_value(),
                filter_range_max_value: self.filter_range_max_value(),
            })
        }
    }

    impl FontWrite for ConditionFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let format: u16 = 1;
            format.write_into(writer);
            self.axis_index.write_into(writer);
            self.filter_range_min_value.write_into(writer);
            self.filter_range_max_value.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureTableSubstitution {
        pub substitutions: Vec<FeatureTableSubstitutionRecord>,
    }

    impl ToOwnedObj for super::FeatureTableSubstitution<'_> {
        type Owned = FeatureTableSubstitution;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(FeatureTableSubstitution {
                substitutions: self
                    .substitutions()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::FeatureTableSubstitution<'_> {}

    impl FontWrite for FeatureTableSubstitution {
        fn write_into(&self, writer: &mut TableWriter) {
            let major_version: u16 = 1;
            major_version.write_into(writer);
            let minor_version: u16 = 0;
            minor_version.write_into(writer);
            u16::try_from(self.substitutions.len())
                .unwrap()
                .write_into(writer);
            self.substitutions.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FeatureTableSubstitutionRecord {
        pub feature_index: u16,
        pub alternate_feature_offset: OffsetMarker<Offset32, Feature>,
    }

    impl ToOwnedObj for super::FeatureTableSubstitutionRecord {
        type Owned = FeatureTableSubstitutionRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(FeatureTableSubstitutionRecord {
                feature_index: self.feature_index(),
                alternate_feature_offset: OffsetMarker::new_maybe_null(
                    self.alternate_feature_offset()
                        .read::<super::Feature>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for FeatureTableSubstitutionRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.feature_index.write_into(writer);
            self.alternate_feature_offset.write_into(writer);
        }
    }
}

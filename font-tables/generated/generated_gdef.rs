// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

use crate::layout::ClassDef;
use crate::layout::CoverageTable;
use font_types::*;

/// [GDEF](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#gdef-header) 1.0
pub struct Gdef1_0<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    attach_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lig_caret_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_attach_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gdef1_0<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (attach_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lig_caret_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_attach_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gdef1_0 {
            major_version,
            minor_version,
            glyph_class_def_offset,
            attach_list_offset,
            lig_caret_list_offset,
            mark_attach_class_def_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gdef1_0<'a> {
    /// Major version of the GDEF table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GDEF table, = 0
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to class definition table for glyph type, from beginning
    /// of GDEF header (may be NULL)
    pub fn glyph_class_def_offset(&self) -> Offset16 {
        self.glyph_class_def_offset.get()
    }

    /// Offset to attachment point list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn attach_list_offset(&self) -> Offset16 {
        self.attach_list_offset.get()
    }

    /// Offset to ligature caret list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn lig_caret_list_offset(&self) -> Offset16 {
        self.lig_caret_list_offset.get()
    }

    /// Offset to class definition table for mark attachment type, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_attach_class_def_offset(&self) -> Offset16 {
        self.mark_attach_class_def_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Gdef1_0<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [GDEF](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#gdef-header) 1.2
pub struct Gdef1_2<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    attach_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lig_caret_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_attach_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_glyph_sets_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gdef1_2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (attach_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lig_caret_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_attach_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_glyph_sets_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gdef1_2 {
            major_version,
            minor_version,
            glyph_class_def_offset,
            attach_list_offset,
            lig_caret_list_offset,
            mark_attach_class_def_offset,
            mark_glyph_sets_def_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gdef1_2<'a> {
    /// Major version of the GDEF table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GDEF table, = 2
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to class definition table for glyph type, from beginning
    /// of GDEF header (may be NULL)
    pub fn glyph_class_def_offset(&self) -> Offset16 {
        self.glyph_class_def_offset.get()
    }

    /// Offset to attachment point list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn attach_list_offset(&self) -> Offset16 {
        self.attach_list_offset.get()
    }

    /// Offset to ligature caret list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn lig_caret_list_offset(&self) -> Offset16 {
        self.lig_caret_list_offset.get()
    }

    /// Offset to class definition table for mark attachment type, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_attach_class_def_offset(&self) -> Offset16 {
        self.mark_attach_class_def_offset.get()
    }

    /// Offset to the table of mark glyph set definitions, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_glyph_sets_def_offset(&self) -> Offset16 {
        self.mark_glyph_sets_def_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Gdef1_2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [GDEF](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#gdef-header) 1.3
pub struct Gdef1_3<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    attach_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lig_caret_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_attach_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_glyph_sets_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    item_var_store_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset32>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gdef1_3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (attach_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lig_caret_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_attach_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_glyph_sets_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (item_var_store_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset32>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gdef1_3 {
            major_version,
            minor_version,
            glyph_class_def_offset,
            attach_list_offset,
            lig_caret_list_offset,
            mark_attach_class_def_offset,
            mark_glyph_sets_def_offset,
            item_var_store_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gdef1_3<'a> {
    /// Major version of the GDEF table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GDEF table, = 3
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to class definition table for glyph type, from beginning
    /// of GDEF header (may be NULL)
    pub fn glyph_class_def_offset(&self) -> Offset16 {
        self.glyph_class_def_offset.get()
    }

    /// Offset to attachment point list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn attach_list_offset(&self) -> Offset16 {
        self.attach_list_offset.get()
    }

    /// Offset to ligature caret list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn lig_caret_list_offset(&self) -> Offset16 {
        self.lig_caret_list_offset.get()
    }

    /// Offset to class definition table for mark attachment type, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_attach_class_def_offset(&self) -> Offset16 {
        self.mark_attach_class_def_offset.get()
    }

    /// Offset to the table of mark glyph set definitions, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_glyph_sets_def_offset(&self) -> Offset16 {
        self.mark_glyph_sets_def_offset.get()
    }

    /// Offset to the Item Variation Store table, from beginning of
    /// GDEF header (may be NULL)
    pub fn item_var_store_offset(&self) -> Offset32 {
        self.item_var_store_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Gdef1_3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum Gdef<'a> {
    Gdef1_0(Gdef1_0<'a>),
    Gdef1_2(Gdef1_2<'a>),
    Gdef1_3(Gdef1_3<'a>),
}

impl<'a> font_types::FontRead<'a> for Gdef<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        const _: MajorMinor = MajorMinor::VERSION_1_0;
        const _: MajorMinor = MajorMinor::VERSION_1_2;
        const _: MajorMinor = MajorMinor::VERSION_1_3;
        let version: BigEndian<MajorMinor> = font_types::FontRead::read(bytes)?;
        match version.get() {
            MajorMinor::VERSION_1_0 => Some(Self::Gdef1_0(font_types::FontRead::read(bytes)?)),
            MajorMinor::VERSION_1_2 => Some(Self::Gdef1_2(font_types::FontRead::read(bytes)?)),
            MajorMinor::VERSION_1_3 => Some(Self::Gdef1_3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(Gdef)
                    );
                }
                None
            }
        }
    }
}

impl<'a> Gdef<'a> {
    /// Offset to attachment point list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn attach_list_offset(&self) -> Offset16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.attach_list_offset(),
            Self::Gdef1_2(_inner) => _inner.attach_list_offset(),
            Self::Gdef1_3(_inner) => _inner.attach_list_offset(),
        }
    }

    /// Offset to class definition table for glyph type, from beginning
    /// of GDEF header (may be NULL)
    pub fn glyph_class_def_offset(&self) -> Offset16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.glyph_class_def_offset(),
            Self::Gdef1_2(_inner) => _inner.glyph_class_def_offset(),
            Self::Gdef1_3(_inner) => _inner.glyph_class_def_offset(),
        }
    }

    /// Offset to the Item Variation Store table, from beginning of
    /// GDEF header (may be NULL)
    pub fn item_var_store_offset(&self) -> Option<Offset32> {
        match self {
            Self::Gdef1_0(_inner) => None,
            Self::Gdef1_2(_inner) => None,
            Self::Gdef1_3(_inner) => Some(_inner.item_var_store_offset()),
        }
    }

    /// Offset to ligature caret list table, from beginning of GDEF
    /// header (may be NULL)
    pub fn lig_caret_list_offset(&self) -> Offset16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.lig_caret_list_offset(),
            Self::Gdef1_2(_inner) => _inner.lig_caret_list_offset(),
            Self::Gdef1_3(_inner) => _inner.lig_caret_list_offset(),
        }
    }

    /// Major version of the GDEF table, = 1
    pub fn major_version(&self) -> u16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.major_version(),
            Self::Gdef1_2(_inner) => _inner.major_version(),
            Self::Gdef1_3(_inner) => _inner.major_version(),
        }
    }

    /// Offset to class definition table for mark attachment type, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_attach_class_def_offset(&self) -> Offset16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.mark_attach_class_def_offset(),
            Self::Gdef1_2(_inner) => _inner.mark_attach_class_def_offset(),
            Self::Gdef1_3(_inner) => _inner.mark_attach_class_def_offset(),
        }
    }

    /// Offset to the table of mark glyph set definitions, from
    /// beginning of GDEF header (may be NULL)
    pub fn mark_glyph_sets_def_offset(&self) -> Option<Offset16> {
        match self {
            Self::Gdef1_0(_inner) => None,
            Self::Gdef1_2(_inner) => Some(_inner.mark_glyph_sets_def_offset()),
            Self::Gdef1_3(_inner) => Some(_inner.mark_glyph_sets_def_offset()),
        }
    }

    /// Minor version of the GDEF table, = 0
    pub fn minor_version(&self) -> u16 {
        match self {
            Self::Gdef1_0(_inner) => _inner.minor_version(),
            Self::Gdef1_2(_inner) => _inner.minor_version(),
            Self::Gdef1_3(_inner) => _inner.minor_version(),
        }
    }
}

impl<'a> font_types::OffsetHost<'a> for Gdef<'a> {
    fn bytes(&self) -> &'a [u8] {
        match self {
            Self::Gdef1_0(_inner) => _inner.bytes(),
            Self::Gdef1_2(_inner) => _inner.bytes(),
            Self::Gdef1_3(_inner) => _inner.bytes(),
        }
    }
}

/// Used in the [Glyph Class Definition Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#glyph-class-definition-table)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum GlyphClassDef {
    Base = 1,
    Ligature = 2,
    Mark = 3,
    Component = 4,
    Unknown,
}

impl GlyphClassDef {
    #[doc = r" Create from a raw scalar."]
    #[doc = r""]
    #[doc = r" This will never fail; unknown values will be mapped to the `Unknown` variant"]
    pub fn new(raw: u16) -> Self {
        match raw {
            1 => Self::Base,
            2 => Self::Ligature,
            3 => Self::Mark,
            4 => Self::Component,
            _ => Self::Unknown,
        }
    }
}

/// [Attachment Point List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#attachment-point-list-table)
pub struct AttachList<'a> {
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    attach_point_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for AttachList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (attach_point_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize as usize,
            )?;
        let _bytes = bytes;
        let result = AttachList {
            coverage_offset,
            glyph_count,
            attach_point_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> AttachList<'a> {
    /// Offset to Coverage table - from beginning of AttachList table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Number of glyphs with attachment points
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Array of offsets to AttachPoint tables-from beginning of
    /// AttachList table-in Coverage Index order
    pub fn attach_point_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.attach_point_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for AttachList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [AttachList]
pub struct AttachPoint<'a> {
    point_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    point_indices: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for AttachPoint<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (point_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_point_count = point_count.get();
        let (point_indices, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_point_count as usize as usize,
            )?;
        let _bytes = bytes;
        let result = AttachPoint {
            point_count,
            point_indices,
        };
        Some(result)
    }
}

impl<'a> AttachPoint<'a> {
    /// Number of attachment points on this glyph
    pub fn point_count(&self) -> u16 {
        self.point_count.get()
    }

    /// Array of contour point indices -in increasing numerical order
    pub fn point_indices(&self) -> &[BigEndian<u16>] {
        &self.point_indices
    }
}

/// [Ligature Caret List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#ligature-caret-list-table)
pub struct LigCaretList<'a> {
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lig_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lig_glyph_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for LigCaretList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lig_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lig_glyph_count = lig_glyph_count.get();
        let (lig_glyph_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lig_glyph_count as usize as usize,
            )?;
        let _bytes = bytes;
        let result = LigCaretList {
            coverage_offset,
            lig_glyph_count,
            lig_glyph_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> LigCaretList<'a> {
    /// Offset to Coverage table - from beginning of LigCaretList table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Number of ligature glyphs
    pub fn lig_glyph_count(&self) -> u16 {
        self.lig_glyph_count.get()
    }

    /// Array of offsets to LigGlyph tables, from beginning of
    /// LigCaretList table —in Coverage Index order
    pub fn lig_glyph_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.lig_glyph_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LigCaretList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Ligature Glyph Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#ligature-glyph-table)
pub struct LigGlyph<'a> {
    caret_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    caret_value_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for LigGlyph<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (caret_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_caret_count = caret_count.get();
        let (caret_value_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_caret_count as usize as usize,
            )?;
        let _bytes = bytes;
        let result = LigGlyph {
            caret_count,
            caret_value_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> LigGlyph<'a> {
    /// Number of CaretValue tables for this ligature (components - 1)
    pub fn caret_count(&self) -> u16 {
        self.caret_count.get()
    }

    /// Array of offsets to CaretValue tables, from beginning of
    /// LigGlyph table — in increasing coordinate order
    pub fn caret_value_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.caret_value_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LigGlyph<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Caret Value Tables](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caret-value-tables)
pub enum CaretValue<'a> {
    Format1(CaretValueFormat1),
    Format2(CaretValueFormat2),
    Format3(CaretValueFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for CaretValue<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(CaretValue)
                    );
                }
                None
            }
        }
    }
}

/// [CaretValue Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-1)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct CaretValueFormat1 {
    /// Format identifier: format = 1
    pub caret_value_format: BigEndian<u16>,
    /// X or Y value, in design units
    pub coordinate: BigEndian<i16>,
}

impl CaretValueFormat1 {
    /// Format identifier: format = 1
    pub fn caret_value_format(&self) -> u16 {
        self.caret_value_format.get()
    }

    /// X or Y value, in design units
    pub fn coordinate(&self) -> i16 {
        self.coordinate.get()
    }
}

/// [CaretValue Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-2)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct CaretValueFormat2 {
    /// Format identifier: format = 2
    pub caret_value_format: BigEndian<u16>,
    /// Contour point index on glyph
    pub caret_value_point_index: BigEndian<u16>,
}

impl CaretValueFormat2 {
    /// Format identifier: format = 2
    pub fn caret_value_format(&self) -> u16 {
        self.caret_value_format.get()
    }

    /// Contour point index on glyph
    pub fn caret_value_point_index(&self) -> u16 {
        self.caret_value_point_index.get()
    }
}

/// [CaretValue Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-3)
pub struct CaretValueFormat3<'a> {
    caret_value_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coordinate: zerocopy::LayoutVerified<&'a [u8], BigEndian<i16>>,
    device_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for CaretValueFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (caret_value_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coordinate, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<i16>>::new_unaligned_from_prefix(bytes)?;
        let (device_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = CaretValueFormat3 {
            caret_value_format,
            coordinate,
            device_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> CaretValueFormat3<'a> {
    /// Format identifier-format = 3
    pub fn caret_value_format(&self) -> u16 {
        self.caret_value_format.get()
    }

    /// X or Y value, in design units
    pub fn coordinate(&self) -> i16 {
        self.coordinate.get()
    }

    /// Offset to Device table (non-variable font) / Variation Index
    /// table (variable font) for X or Y value-from beginning of
    /// CaretValue table
    pub fn device_offset(&self) -> Offset16 {
        self.device_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for CaretValueFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Mark Glyph Sets Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#mark-glyph-sets-table)
pub struct MarkGlyphSets<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_glyph_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset32>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkGlyphSets<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_glyph_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_mark_glyph_set_count = mark_glyph_set_count.get();
        let (coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset32>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_glyph_set_count as usize as usize,
            )?;
        let _bytes = bytes;
        let result = MarkGlyphSets {
            format,
            mark_glyph_set_count,
            coverage_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkGlyphSets<'a> {
    /// Format identifier == 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Number of mark glyph sets defined
    pub fn mark_glyph_set_count(&self) -> u16 {
        self.mark_glyph_set_count.get()
    }

    /// Array of offsets to mark glyph set coverage tables, from the
    /// start of the MarkGlyphSets table.
    pub fn coverage_offsets(&self) -> &[BigEndian<Offset32>] {
        &self.coverage_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkGlyphSets<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

#[cfg(feature = "compile")]
pub mod compile {
    use super::super::compile::AttachList;
    use super::super::compile::CaretValueFormat3;
    use crate::compile::*;
    use crate::layout::compile::ClassDef;
    use crate::layout::compile::CoverageTable;
    use font_types::{Offset as _, OffsetHost as _};

    #[derive(Debug, Default, PartialEq)]
    pub struct Gdef1_0 {
        pub glyph_class_def_offset: OffsetMarker16<ClassDef>,
        pub attach_list_offset: OffsetMarker16<AttachList>,
        pub lig_caret_list_offset: OffsetMarker16<LigCaretList>,
        pub mark_attach_class_def_offset: OffsetMarker16<ClassDef>,
    }

    impl ToOwnedObj for super::Gdef1_0<'_> {
        type Owned = Gdef1_0;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Gdef1_0 {
                glyph_class_def_offset: OffsetMarker::new_maybe_null(
                    self.glyph_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                attach_list_offset: OffsetMarker::new_maybe_null(
                    self.attach_list_offset()
                        .read::<super::AttachList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lig_caret_list_offset: OffsetMarker::new_maybe_null(
                    self.lig_caret_list_offset()
                        .read::<super::LigCaretList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_attach_class_def_offset: OffsetMarker::new_maybe_null(
                    self.mark_attach_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::Gdef1_0<'_> {}

    impl FontWrite for Gdef1_0 {
        fn write_into(&self, writer: &mut TableWriter) {
            (1 as u16).write_into(writer);
            (0 as u16).write_into(writer);
            self.glyph_class_def_offset.write_into(writer);
            self.attach_list_offset.write_into(writer);
            self.lig_caret_list_offset.write_into(writer);
            self.mark_attach_class_def_offset.write_into(writer);
        }
    }

    impl Gdef1_0 {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct Gdef1_2 {
        pub glyph_class_def_offset: OffsetMarker16<ClassDef>,
        pub attach_list_offset: OffsetMarker16<AttachList>,
        pub lig_caret_list_offset: OffsetMarker16<LigCaretList>,
        pub mark_attach_class_def_offset: OffsetMarker16<ClassDef>,
        pub mark_glyph_sets_def_offset: OffsetMarker16<MarkGlyphSets>,
    }

    impl ToOwnedObj for super::Gdef1_2<'_> {
        type Owned = Gdef1_2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Gdef1_2 {
                glyph_class_def_offset: OffsetMarker::new_maybe_null(
                    self.glyph_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                attach_list_offset: OffsetMarker::new_maybe_null(
                    self.attach_list_offset()
                        .read::<super::AttachList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lig_caret_list_offset: OffsetMarker::new_maybe_null(
                    self.lig_caret_list_offset()
                        .read::<super::LigCaretList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_attach_class_def_offset: OffsetMarker::new_maybe_null(
                    self.mark_attach_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_glyph_sets_def_offset: OffsetMarker::new_maybe_null(
                    self.mark_glyph_sets_def_offset()
                        .read::<super::MarkGlyphSets>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::Gdef1_2<'_> {}

    impl FontWrite for Gdef1_2 {
        fn write_into(&self, writer: &mut TableWriter) {
            (1 as u16).write_into(writer);
            (2 as u16).write_into(writer);
            self.glyph_class_def_offset.write_into(writer);
            self.attach_list_offset.write_into(writer);
            self.lig_caret_list_offset.write_into(writer);
            self.mark_attach_class_def_offset.write_into(writer);
            self.mark_glyph_sets_def_offset.write_into(writer);
        }
    }

    impl Gdef1_2 {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct Gdef1_3 {
        pub glyph_class_def_offset: OffsetMarker16<ClassDef>,
        pub attach_list_offset: OffsetMarker16<AttachList>,
        pub lig_caret_list_offset: OffsetMarker16<LigCaretList>,
        pub mark_attach_class_def_offset: OffsetMarker16<ClassDef>,
        pub mark_glyph_sets_def_offset: OffsetMarker16<MarkGlyphSets>,
        pub item_var_store_offset: OffsetMarker32<ClassDef>,
    }

    impl ToOwnedObj for super::Gdef1_3<'_> {
        type Owned = Gdef1_3;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Gdef1_3 {
                glyph_class_def_offset: OffsetMarker::new_maybe_null(
                    self.glyph_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                attach_list_offset: OffsetMarker::new_maybe_null(
                    self.attach_list_offset()
                        .read::<super::AttachList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lig_caret_list_offset: OffsetMarker::new_maybe_null(
                    self.lig_caret_list_offset()
                        .read::<super::LigCaretList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_attach_class_def_offset: OffsetMarker::new_maybe_null(
                    self.mark_attach_class_def_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_glyph_sets_def_offset: OffsetMarker::new_maybe_null(
                    self.mark_glyph_sets_def_offset()
                        .read::<super::MarkGlyphSets>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                item_var_store_offset: OffsetMarker::new_maybe_null(
                    self.item_var_store_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::Gdef1_3<'_> {}

    impl FontWrite for Gdef1_3 {
        fn write_into(&self, writer: &mut TableWriter) {
            (1 as u16).write_into(writer);
            (3 as u16).write_into(writer);
            self.glyph_class_def_offset.write_into(writer);
            self.attach_list_offset.write_into(writer);
            self.lig_caret_list_offset.write_into(writer);
            self.mark_attach_class_def_offset.write_into(writer);
            self.mark_glyph_sets_def_offset.write_into(writer);
            self.item_var_store_offset.write_into(writer);
        }
    }

    impl Gdef1_3 {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum Gdef {
        Gdef1_0(Gdef1_0),
        Gdef1_2(Gdef1_2),
        Gdef1_3(Gdef1_3),
    }

    impl ToOwnedObj for super::Gdef<'_> {
        type Owned = Gdef;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::Gdef::Gdef1_0(item) => Gdef::Gdef1_0(item.to_owned_obj(offset_data)?),
                super::Gdef::Gdef1_2(item) => Gdef::Gdef1_2(item.to_owned_obj(offset_data)?),
                super::Gdef::Gdef1_3(item) => Gdef::Gdef1_3(item.to_owned_obj(offset_data)?),
            })
        }
    }

    impl ToOwnedTable for super::Gdef<'_> {}

    impl FontWrite for Gdef {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Gdef1_0(item) => item.write_into(writer),
                Self::Gdef1_2(item) => item.write_into(writer),
                Self::Gdef1_3(item) => item.write_into(writer),
            }
        }
    }

    impl Default for Gdef {
        fn default() -> Self {
            Self::Gdef1_0(Default::default())
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct AttachPoint {
        pub point_indices: Vec<u16>,
    }

    impl ToOwnedObj for super::AttachPoint<'_> {
        type Owned = AttachPoint;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(AttachPoint {
                point_indices: self
                    .point_indices()
                    .iter()
                    .map(|item| Some(item.get()))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for AttachPoint {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.point_indices.len())
                .unwrap()
                .write_into(writer);
            self.point_indices.write_into(writer);
        }
    }

    impl AttachPoint {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct LigCaretList {
        pub coverage_offset: OffsetMarker16<CoverageTable>,
        pub lig_glyph_offsets: Vec<OffsetMarker16<LigGlyph>>,
    }

    impl ToOwnedObj for super::LigCaretList<'_> {
        type Owned = LigCaretList;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(LigCaretList {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lig_glyph_offsets: self
                    .lig_glyph_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::LigGlyph>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::LigCaretList<'_> {}

    impl FontWrite for LigCaretList {
        fn write_into(&self, writer: &mut TableWriter) {
            self.coverage_offset.write_into(writer);
            u16::try_from(self.lig_glyph_offsets.len())
                .unwrap()
                .write_into(writer);
            self.lig_glyph_offsets.write_into(writer);
        }
    }

    impl LigCaretList {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct LigGlyph {
        pub caret_value_offsets: Vec<OffsetMarker16<CaretValue>>,
    }

    impl ToOwnedObj for super::LigGlyph<'_> {
        type Owned = LigGlyph;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(LigGlyph {
                caret_value_offsets: self
                    .caret_value_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CaretValue>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::LigGlyph<'_> {}

    impl FontWrite for LigGlyph {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.caret_value_offsets.len())
                .unwrap()
                .write_into(writer);
            self.caret_value_offsets.write_into(writer);
        }
    }

    impl LigGlyph {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum CaretValue {
        Format1(CaretValueFormat1),
        Format2(CaretValueFormat2),
        Format3(CaretValueFormat3),
    }

    impl ToOwnedObj for super::CaretValue<'_> {
        type Owned = CaretValue;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::CaretValue::Format1(item) => {
                    CaretValue::Format1(item.to_owned_obj(offset_data)?)
                }
                super::CaretValue::Format2(item) => {
                    CaretValue::Format2(item.to_owned_obj(offset_data)?)
                }
                super::CaretValue::Format3(item) => {
                    CaretValue::Format3(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl FontWrite for CaretValue {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
                Self::Format3(item) => item.write_into(writer),
            }
        }
    }

    impl Default for CaretValue {
        fn default() -> Self {
            Self::Format1(Default::default())
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct CaretValueFormat1 {
        pub coordinate: i16,
    }

    impl ToOwnedObj for super::CaretValueFormat1 {
        type Owned = CaretValueFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(CaretValueFormat1 {
                coordinate: self.coordinate(),
            })
        }
    }

    impl FontWrite for CaretValueFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            (1 as u16).write_into(writer);
            self.coordinate.write_into(writer);
        }
    }

    impl CaretValueFormat1 {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct CaretValueFormat2 {
        pub caret_value_point_index: u16,
    }

    impl ToOwnedObj for super::CaretValueFormat2 {
        type Owned = CaretValueFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(CaretValueFormat2 {
                caret_value_point_index: self.caret_value_point_index(),
            })
        }
    }

    impl FontWrite for CaretValueFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            (2 as u16).write_into(writer);
            self.caret_value_point_index.write_into(writer);
        }
    }

    impl CaretValueFormat2 {
        pub fn new() -> Self {
            Default::default()
        }
    }

    #[derive(Debug, Default, PartialEq)]
    pub struct MarkGlyphSets {
        pub coverage_offsets: Vec<OffsetMarker32<CoverageTable>>,
    }

    impl ToOwnedObj for super::MarkGlyphSets<'_> {
        type Owned = MarkGlyphSets;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(MarkGlyphSets {
                coverage_offsets: self
                    .coverage_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::CoverageTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::MarkGlyphSets<'_> {}

    impl FontWrite for MarkGlyphSets {
        fn write_into(&self, writer: &mut TableWriter) {
            (1 as u16).write_into(writer);
            u16::try_from(self.coverage_offsets.len())
                .unwrap()
                .write_into(writer);
            self.coverage_offsets.write_into(writer);
        }
    }

    impl MarkGlyphSets {
        pub fn new() -> Self {
            Default::default()
        }
    }
}

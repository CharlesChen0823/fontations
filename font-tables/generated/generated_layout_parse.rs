// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

use font_types::*;

/// [Script List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-list-table-and-script-record)
pub struct ScriptList<'a> {
    script_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_records: zerocopy::LayoutVerified<&'a [u8], [ScriptRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ScriptList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (script_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_script_count = script_count.get();
        let (script_records, bytes) =
            zerocopy::LayoutVerified::<_, [ScriptRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_script_count as usize,
            )?;
        let _bytes = bytes;
        let result = ScriptList {
            script_count,
            script_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ScriptList<'a> {
    /// Number of ScriptRecords
    pub fn script_count(&self) -> u16 {
        self.script_count.get()
    }

    /// Array of ScriptRecords, listed alphabetically by script tag
    pub fn script_records(&self) -> &[ScriptRecord] {
        &self.script_records
    }
}

impl<'a> font_types::OffsetHost<'a> for ScriptList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Script Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-list-table-and-script-record)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ScriptRecord {
    /// 4-byte script tag identifier
    pub script_tag: BigEndian<Tag>,
    /// Offset to Script table, from beginning of ScriptList
    pub script_offset: BigEndian<Offset16>,
}

impl ScriptRecord {
    /// 4-byte script tag identifier
    pub fn script_tag(&self) -> Tag {
        self.script_tag.get()
    }

    /// Offset to Script table, from beginning of ScriptList
    pub fn script_offset(&self) -> Offset16 {
        self.script_offset.get()
    }
}

/// [Script Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-table-and-language-system-record)
pub struct Script<'a> {
    default_lang_sys_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lang_sys_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lang_sys_records: zerocopy::LayoutVerified<&'a [u8], [LangSysRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Script<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (default_lang_sys_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lang_sys_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lang_sys_count = lang_sys_count.get();
        let (lang_sys_records, bytes) =
            zerocopy::LayoutVerified::<_, [LangSysRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lang_sys_count as usize,
            )?;
        let _bytes = bytes;
        let result = Script {
            default_lang_sys_offset,
            lang_sys_count,
            lang_sys_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Script<'a> {
    /// Offset to default LangSys table, from beginning of Script table
    /// — may be NULL
    pub fn default_lang_sys_offset(&self) -> Offset16 {
        self.default_lang_sys_offset.get()
    }

    pub fn default_lang_sys(&self) -> Option<LangSys> {
        self.default_lang_sys_offset().read(self.bytes())
    }

    /// Number of LangSysRecords for this script — excluding the
    /// default LangSys
    pub fn lang_sys_count(&self) -> u16 {
        self.lang_sys_count.get()
    }

    /// Array of LangSysRecords, listed alphabetically by LangSys tag
    pub fn lang_sys_records(&self) -> &[LangSysRecord] {
        &self.lang_sys_records
    }
}

impl<'a> font_types::OffsetHost<'a> for Script<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct LangSysRecord {
    /// 4-byte LangSysTag identifier
    pub lang_sys_tag: BigEndian<Tag>,
    /// Offset to LangSys table, from beginning of Script table
    pub lang_sys_offset: BigEndian<Offset16>,
}

impl LangSysRecord {
    /// 4-byte LangSysTag identifier
    pub fn lang_sys_tag(&self) -> Tag {
        self.lang_sys_tag.get()
    }

    /// Offset to LangSys table, from beginning of Script table
    pub fn lang_sys_offset(&self) -> Offset16 {
        self.lang_sys_offset.get()
    }
}

/// [Language System Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#language-system-table)
pub struct LangSys<'a> {
    #[allow(dead_code)]
    lookup_order_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    required_feature_index: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_index_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_indices: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for LangSys<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (lookup_order_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (required_feature_index, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_index_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_index_count = feature_index_count.get();
        let (feature_indices, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_feature_index_count as usize,
            )?;
        let _bytes = bytes;
        let result = LangSys {
            lookup_order_offset,
            required_feature_index,
            feature_index_count,
            feature_indices,
        };
        Some(result)
    }
}

impl<'a> LangSys<'a> {
    /// Index of a feature required for this language system; if no
    /// required features = 0xFFFF
    pub fn required_feature_index(&self) -> u16 {
        self.required_feature_index.get()
    }

    /// Number of feature index values for this language system —
    /// excludes the required feature
    pub fn feature_index_count(&self) -> u16 {
        self.feature_index_count.get()
    }

    /// Array of indices into the FeatureList, in arbitrary order
    pub fn feature_indices(&self) -> &[BigEndian<u16>] {
        &self.feature_indices
    }
}

/// [Feature List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-list-table)
pub struct FeatureList<'a> {
    feature_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_records: zerocopy::LayoutVerified<&'a [u8], [FeatureRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (feature_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_count = feature_count.get();
        let (feature_records, bytes) =
            zerocopy::LayoutVerified::<_, [FeatureRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_feature_count as usize,
            )?;
        let _bytes = bytes;
        let result = FeatureList {
            feature_count,
            feature_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureList<'a> {
    /// Number of FeatureRecords in this table
    pub fn feature_count(&self) -> u16 {
        self.feature_count.get()
    }

    /// Array of FeatureRecords — zero-based (first feature has
    /// FeatureIndex = 0), listed alphabetically by feature tag
    pub fn feature_records(&self) -> &[FeatureRecord] {
        &self.feature_records
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [FeatureList]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureRecord {
    /// 4-byte feature identification tag
    pub feature_tag: BigEndian<Tag>,
    /// Offset to Feature table, from beginning of FeatureList
    pub feature_offset: BigEndian<Offset16>,
}

impl FeatureRecord {
    /// 4-byte feature identification tag
    pub fn feature_tag(&self) -> Tag {
        self.feature_tag.get()
    }

    /// Offset to Feature table, from beginning of FeatureList
    pub fn feature_offset(&self) -> Offset16 {
        self.feature_offset.get()
    }
}

/// [Feature Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-table)
pub struct Feature<'a> {
    feature_params_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookup_index_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_list_indices: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Feature<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (feature_params_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_index_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookup_index_count = lookup_index_count.get();
        let (lookup_list_indices, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookup_index_count as usize,
            )?;
        let _bytes = bytes;
        let result = Feature {
            feature_params_offset,
            lookup_index_count,
            lookup_list_indices,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Feature<'a> {
    /// Offset from start of Feature table to FeatureParams table, if defined for the feature and present, else NULL
    pub fn feature_params_offset(&self) -> Offset16 {
        self.feature_params_offset.get()
    }

    /// Number of LookupList indices for this feature
    pub fn lookup_index_count(&self) -> u16 {
        self.lookup_index_count.get()
    }

    /// Array of indices into the LookupList — zero-based (first
    /// lookup is LookupListIndex = 0)
    pub fn lookup_list_indices(&self) -> &[BigEndian<u16>] {
        &self.lookup_list_indices
    }
}

impl<'a> font_types::OffsetHost<'a> for Feature<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Lookup List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-list-table)
pub struct LookupList<'a> {
    lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for LookupList<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookup_count = lookup_count.get();
        let (lookup_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = LookupList {
            lookup_count,
            lookup_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> LookupList<'a> {
    /// Number of lookups in this table
    pub fn lookup_count(&self) -> u16 {
        self.lookup_count.get()
    }

    /// Array of offsets to Lookup tables, from beginning of LookupList
    /// — zero based (first lookup is Lookup index = 0)
    pub fn lookup_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.lookup_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LookupList<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Lookup Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-table)
pub struct Lookup<'a> {
    lookup_type: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookup_flag: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    sub_table_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    subtable_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    mark_filtering_set: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Lookup<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (lookup_type, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_flag, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (sub_table_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_sub_table_count = sub_table_count.get();
        let (subtable_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_sub_table_count as usize,
            )?;
        let (mark_filtering_set, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Lookup {
            lookup_type,
            lookup_flag,
            sub_table_count,
            subtable_offsets,
            mark_filtering_set,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Lookup<'a> {
    /// Different enumerations for GSUB and GPOS
    pub fn lookup_type(&self) -> u16 {
        self.lookup_type.get()
    }

    /// Lookup qualifiers
    pub fn lookup_flag(&self) -> u16 {
        self.lookup_flag.get()
    }

    /// Number of subtables for this lookup
    pub fn sub_table_count(&self) -> u16 {
        self.sub_table_count.get()
    }

    /// Array of offsets to lookup subtables, from beginning of Lookup
    /// table
    pub fn subtable_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.subtable_offsets
    }

    /// Index (base 0) into GDEF mark glyph sets structure. This field
    /// is only present if the USE_MARK_FILTERING_SET lookup flag is
    /// set.
    pub fn mark_filtering_set(&self) -> u16 {
        self.mark_filtering_set.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Lookup<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Coverage Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-1)
pub struct CoverageFormat1<'a> {
    coverage_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for CoverageFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (coverage_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (glyph_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let _bytes = bytes;
        let result = CoverageFormat1 {
            coverage_format,
            glyph_count,
            glyph_array,
        };
        Some(result)
    }
}

impl<'a> CoverageFormat1<'a> {
    /// Format identifier — format = 1
    pub fn coverage_format(&self) -> u16 {
        self.coverage_format.get()
    }

    /// Number of glyphs in the glyph array
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Array of glyph IDs — in numerical order
    pub fn glyph_array(&self) -> &[BigEndian<u16>] {
        &self.glyph_array
    }
}

/// [Coverage Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-2)
pub struct CoverageFormat2<'a> {
    coverage_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    range_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    range_records: zerocopy::LayoutVerified<&'a [u8], [RangeRecord]>,
}

impl<'a> font_types::FontRead<'a> for CoverageFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (coverage_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (range_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_range_count = range_count.get();
        let (range_records, bytes) =
            zerocopy::LayoutVerified::<_, [RangeRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_range_count as usize,
            )?;
        let _bytes = bytes;
        let result = CoverageFormat2 {
            coverage_format,
            range_count,
            range_records,
        };
        Some(result)
    }
}

impl<'a> CoverageFormat2<'a> {
    /// Format identifier — format = 2
    pub fn coverage_format(&self) -> u16 {
        self.coverage_format.get()
    }

    /// Number of RangeRecords
    pub fn range_count(&self) -> u16 {
        self.range_count.get()
    }

    /// Array of glyph ranges — ordered by startGlyphID.
    pub fn range_records(&self) -> &[RangeRecord] {
        &self.range_records
    }
}

/// Used in [CoverageFormat2]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct RangeRecord {
    /// First glyph ID in the range
    pub start_glyph_id: BigEndian<u16>,
    /// Last glyph ID in the range
    pub end_glyph_id: BigEndian<u16>,
    /// Coverage Index of first glyph ID in range
    pub start_coverage_index: BigEndian<u16>,
}

impl RangeRecord {
    /// First glyph ID in the range
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Last glyph ID in the range
    pub fn end_glyph_id(&self) -> u16 {
        self.end_glyph_id.get()
    }

    /// Coverage Index of first glyph ID in range
    pub fn start_coverage_index(&self) -> u16 {
        self.start_coverage_index.get()
    }
}

/// [Coverage Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table)
pub enum CoverageTable<'a> {
    Format1(CoverageFormat1<'a>),
    Format2(CoverageFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for CoverageTable<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(CoverageTable)
                    );
                }
                None
            }
        }
    }
}

/// [Class Definition Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-1)
pub struct ClassDefFormat1<'a> {
    class_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    start_glyph_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_value_array: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for ClassDefFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (class_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (start_glyph_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (class_value_array, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassDefFormat1 {
            class_format,
            start_glyph_id,
            glyph_count,
            class_value_array,
        };
        Some(result)
    }
}

impl<'a> ClassDefFormat1<'a> {
    /// Format identifier — format = 1
    pub fn class_format(&self) -> u16 {
        self.class_format.get()
    }

    /// First glyph ID of the classValueArray
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Size of the classValueArray
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Array of Class Values — one per glyph ID
    pub fn class_value_array(&self) -> &[BigEndian<u16>] {
        &self.class_value_array
    }
}

/// [Class Definition Table Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-2)
pub struct ClassDefFormat2<'a> {
    class_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_range_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_range_records: zerocopy::LayoutVerified<&'a [u8], [ClassRangeRecord]>,
}

impl<'a> font_types::FontRead<'a> for ClassDefFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (class_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (class_range_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_range_count = class_range_count.get();
        let (class_range_records, bytes) =
            zerocopy::LayoutVerified::<_, [ClassRangeRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_range_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassDefFormat2 {
            class_format,
            class_range_count,
            class_range_records,
        };
        Some(result)
    }
}

impl<'a> ClassDefFormat2<'a> {
    /// Format identifier — format = 2
    pub fn class_format(&self) -> u16 {
        self.class_format.get()
    }

    /// Number of ClassRangeRecords
    pub fn class_range_count(&self) -> u16 {
        self.class_range_count.get()
    }

    /// Array of ClassRangeRecords — ordered by startGlyphID
    pub fn class_range_records(&self) -> &[ClassRangeRecord] {
        &self.class_range_records
    }
}

/// Used in [ClassDefFormat2]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ClassRangeRecord {
    /// First glyph ID in the range
    pub start_glyph_id: BigEndian<u16>,
    /// Last glyph ID in the range
    pub end_glyph_id: BigEndian<u16>,
    /// Applied to all glyphs in the range
    pub class: BigEndian<u16>,
}

impl ClassRangeRecord {
    /// First glyph ID in the range
    pub fn start_glyph_id(&self) -> u16 {
        self.start_glyph_id.get()
    }

    /// Last glyph ID in the range
    pub fn end_glyph_id(&self) -> u16 {
        self.end_glyph_id.get()
    }

    /// Applied to all glyphs in the range
    pub fn class(&self) -> u16 {
        self.class.get()
    }
}

pub enum ClassDef<'a> {
    Format1(ClassDefFormat1<'a>),
    Format2(ClassDefFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for ClassDef<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(ClassDef)
                    );
                }
                None
            }
        }
    }
}

/// [Sequence Lookup Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-lookup-record)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct SequenceLookupRecord {
    /// Index (zero-based) into the input glyph sequence
    pub sequence_index: BigEndian<u16>,
    /// Index (zero-based) into the LookupList
    pub lookup_list_index: BigEndian<u16>,
}

impl SequenceLookupRecord {
    /// Index (zero-based) into the input glyph sequence
    pub fn sequence_index(&self) -> u16 {
        self.sequence_index.get()
    }

    /// Index (zero-based) into the LookupList
    pub fn lookup_list_index(&self) -> u16 {
        self.lookup_list_index.get()
    }
}

/// [Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-1-simple-glyph-contexts)
pub struct SequenceContextFormat1<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_rule_set_count = seq_rule_set_count.get();
        let (seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat1 {
            format,
            coverage_offset,
            seq_rule_set_count,
            seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// SequenceContextFormat1 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Number of SequenceRuleSet tables
    pub fn seq_rule_set_count(&self) -> u16 {
        self.seq_rule_set_count.get()
    }

    /// Array of offsets to SequenceRuleSet tables, from beginning of
    /// SequenceContextFormat1 table (offsets may be NULL)
    pub fn seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.seq_rule_set_offsets
    }

    pub fn seq_rule_set(&self) -> impl Iterator<Item = Option<SequenceRuleSet>> + '_ {
        self.seq_rule_set_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat1]
pub struct SequenceRuleSet<'a> {
    seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_rule_count = seq_rule_count.get();
        let (seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceRuleSet {
            seq_rule_count,
            seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceRuleSet<'a> {
    /// Number of SequenceRule tables
    pub fn seq_rule_count(&self) -> u16 {
        self.seq_rule_count.get()
    }

    /// Array of offsets to SequenceRule tables, from beginning of the
    /// SequenceRuleSet table
    pub fn seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.seq_rule_offsets
    }

    pub fn seq_rule(&self) -> impl Iterator<Item = Option<SequenceRule>> + '_ {
        self.seq_rule_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat1]
pub struct SequenceRule<'a> {
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for SequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_glyph_count) as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceRule {
            glyph_count,
            seq_lookup_count,
            input_sequence,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> SequenceRule<'a> {
    /// Number of glyphs in the input glyph sequence
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of input glyph IDs—starting with the second glyph
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Array of Sequence lookup records
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-2-class-based-glyph-contexts)
pub struct SequenceContextFormat2<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_seq_rule_set_count = class_seq_rule_set_count.get();
        let (class_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat2 {
            format,
            coverage_offset,
            class_def_offset,
            class_seq_rule_set_count,
            class_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// SequenceContextFormat2 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Offset to ClassDef table, from beginning of
    /// SequenceContextFormat2 table
    pub fn class_def_offset(&self) -> Offset16 {
        self.class_def_offset.get()
    }

    pub fn class_def(&self) -> Option<ClassDef> {
        self.class_def_offset().read(self.bytes())
    }

    /// Number of ClassSequenceRuleSet tables
    pub fn class_seq_rule_set_count(&self) -> u16 {
        self.class_seq_rule_set_count.get()
    }

    /// Array of offsets to ClassSequenceRuleSet tables, from beginning
    /// of SequenceContextFormat2 table (may be NULL)
    pub fn class_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.class_seq_rule_set_offsets
    }

    pub fn class_seq_rule_set(&self) -> impl Iterator<Item = Option<ClassSequenceRuleSet>> + '_ {
        self.class_seq_rule_set_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat2]
pub struct ClassSequenceRuleSet<'a> {
    class_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ClassSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (class_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class_seq_rule_count = class_seq_rule_count.get();
        let (class_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_class_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassSequenceRuleSet {
            class_seq_rule_count,
            class_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ClassSequenceRuleSet<'a> {
    /// Number of ClassSequenceRule tables
    pub fn class_seq_rule_count(&self) -> u16 {
        self.class_seq_rule_count.get()
    }

    /// Array of offsets to ClassSequenceRule tables, from beginning of
    /// ClassSequenceRuleSet table
    pub fn class_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.class_seq_rule_offsets
    }

    pub fn class_seq_rule(&self) -> impl Iterator<Item = Option<ClassSequenceRule>> + '_ {
        self.class_seq_rule_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ClassSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [SequenceContextFormat2]
pub struct ClassSequenceRule<'a> {
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ClassSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_glyph_count) as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ClassSequenceRule {
            glyph_count,
            seq_lookup_count,
            input_sequence,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ClassSequenceRule<'a> {
    /// Number of glyphs to be matched
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Sequence of classes to be matched to the input glyph sequence,
    /// beginning with the second glyph position
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-3-coverage-based-glyph-contexts)
pub struct SequenceContextFormat3<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SequenceContextFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_glyph_count = glyph_count.get();
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_glyph_count as usize,
            )?;
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = SequenceContextFormat3 {
            format,
            glyph_count,
            seq_lookup_count,
            coverage_offsets,
            seq_lookup_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SequenceContextFormat3<'a> {
    /// Format identifier: format = 3
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Number of glyphs in the input sequence
    pub fn glyph_count(&self) -> u16 {
        self.glyph_count.get()
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of offsets to Coverage tables, from beginning of
    /// SequenceContextFormat3 subtable
    pub fn coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.coverage_offsets
    }

    pub fn coverage(&self) -> impl Iterator<Item = Option<CoverageTable>> + '_ {
        self.coverage_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

impl<'a> font_types::OffsetHost<'a> for SequenceContextFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum SequenceContext<'a> {
    Format1(SequenceContextFormat1<'a>),
    Format2(SequenceContextFormat2<'a>),
    Format3(SequenceContextFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for SequenceContext<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(SequenceContext)
                    );
                }
                None
            }
        }
    }
}

/// [Chained Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-1-simple-glyph-contexts)
pub struct ChainedSequenceContextFormat1<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    chained_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (chained_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_seq_rule_set_count = chained_seq_rule_set_count.get();
        let (chained_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat1 {
            format,
            coverage_offset,
            chained_seq_rule_set_count,
            chained_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// ChainSequenceContextFormat1 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Number of ChainedSequenceRuleSet tables
    pub fn chained_seq_rule_set_count(&self) -> u16 {
        self.chained_seq_rule_set_count.get()
    }

    /// Array of offsets to ChainedSeqRuleSet tables, from beginning of
    /// ChainedSequenceContextFormat1 table (may be NULL)
    pub fn chained_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_seq_rule_set_offsets
    }

    pub fn chained_seq_rule_set(
        &self,
    ) -> impl Iterator<Item = Option<ChainedSequenceRuleSet>> + '_ {
        self.chained_seq_rule_set_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat1]
pub struct ChainedSequenceRuleSet<'a> {
    chained_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (chained_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_seq_rule_count = chained_seq_rule_count.get();
        let (chained_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceRuleSet {
            chained_seq_rule_count,
            chained_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceRuleSet<'a> {
    /// Number of ChainedSequenceRule tables
    pub fn chained_seq_rule_count(&self) -> u16 {
        self.chained_seq_rule_count.get()
    }

    /// Array of offsets to ChainedSequenceRule tables, from beginning
    /// of ChainedSequenceRuleSet table
    pub fn chained_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_seq_rule_offsets
    }

    pub fn chained_seq_rule(&self) -> impl Iterator<Item = Option<ChainedSequenceRule>> + '_ {
        self.chained_seq_rule_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat1]
pub struct ChainedSequenceRule<'a> {
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_input_glyph_count) as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceRule {
            backtrack_glyph_count,
            backtrack_sequence,
            input_glyph_count,
            input_sequence,
            lookahead_glyph_count,
            lookahead_sequence,
            seq_lookup_count,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceRule<'a> {
    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of backtrack glyph IDs
    pub fn backtrack_sequence(&self) -> &[BigEndian<u16>] {
        &self.backtrack_sequence
    }

    /// Number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of input glyph IDs—start with second glyph
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of lookahead glyph IDs
    pub fn lookahead_sequence(&self) -> &[BigEndian<u16>] {
        &self.lookahead_sequence
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Chained Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-2-class-based-glyph-contexts)
pub struct ChainedSequenceContextFormat2<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    backtrack_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    input_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookahead_class_def_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    chained_class_seq_rule_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_class_seq_rule_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (backtrack_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (input_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookahead_class_def_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (chained_class_seq_rule_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_class_seq_rule_set_count = chained_class_seq_rule_set_count.get();
        let (chained_class_seq_rule_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_class_seq_rule_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat2 {
            format,
            coverage_offset,
            backtrack_class_def_offset,
            input_class_def_offset,
            lookahead_class_def_offset,
            chained_class_seq_rule_set_count,
            chained_class_seq_rule_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Offset to Coverage table, from beginning of
    /// ChainedSequenceContextFormat2 table
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Offset to ClassDef table containing backtrack sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn backtrack_class_def_offset(&self) -> Offset16 {
        self.backtrack_class_def_offset.get()
    }

    pub fn backtrack_class_def(&self) -> Option<ClassDef> {
        self.backtrack_class_def_offset().read(self.bytes())
    }

    /// Offset to ClassDef table containing input sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn input_class_def_offset(&self) -> Offset16 {
        self.input_class_def_offset.get()
    }

    pub fn input_class_def(&self) -> Option<ClassDef> {
        self.input_class_def_offset().read(self.bytes())
    }

    /// Offset to ClassDef table containing lookahead sequence context,
    /// from beginning of ChainedSequenceContextFormat2 table
    pub fn lookahead_class_def_offset(&self) -> Offset16 {
        self.lookahead_class_def_offset.get()
    }

    pub fn lookahead_class_def(&self) -> Option<ClassDef> {
        self.lookahead_class_def_offset().read(self.bytes())
    }

    /// Number of ChainedClassSequenceRuleSet tables
    pub fn chained_class_seq_rule_set_count(&self) -> u16 {
        self.chained_class_seq_rule_set_count.get()
    }

    /// Array of offsets to ChainedClassSequenceRuleSet tables, from
    /// beginning of ChainedSequenceContextFormat2 table (may be NULL)
    pub fn chained_class_seq_rule_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_class_seq_rule_set_offsets
    }

    pub fn chained_class_seq_rule_set(
        &self,
    ) -> impl Iterator<Item = Option<ChainedClassSequenceRuleSet>> + '_ {
        self.chained_class_seq_rule_set_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat2]
pub struct ChainedClassSequenceRuleSet<'a> {
    chained_class_seq_rule_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    chained_class_seq_rule_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedClassSequenceRuleSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (chained_class_seq_rule_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_chained_class_seq_rule_count = chained_class_seq_rule_count.get();
        let (chained_class_seq_rule_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_chained_class_seq_rule_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedClassSequenceRuleSet {
            chained_class_seq_rule_count,
            chained_class_seq_rule_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedClassSequenceRuleSet<'a> {
    /// Number of ChainedClassSequenceRule tables
    pub fn chained_class_seq_rule_count(&self) -> u16 {
        self.chained_class_seq_rule_count.get()
    }

    /// Array of offsets to ChainedClassSequenceRule tables, from
    /// beginning of ChainedClassSequenceRuleSet
    pub fn chained_class_seq_rule_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.chained_class_seq_rule_offsets
    }

    pub fn chained_class_seq_rule(
        &self,
    ) -> impl Iterator<Item = Option<ChainedClassSequenceRule>> + '_ {
        self.chained_class_seq_rule_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedClassSequenceRuleSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [ChainedSequenceContextFormat2]
pub struct ChainedClassSequenceRule<'a> {
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_sequence: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
}

impl<'a> font_types::FontRead<'a> for ChainedClassSequenceRule<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                minus_one(__resolved_input_glyph_count) as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_sequence, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedClassSequenceRule {
            backtrack_glyph_count,
            backtrack_sequence,
            input_glyph_count,
            input_sequence,
            lookahead_glyph_count,
            lookahead_sequence,
            seq_lookup_count,
            seq_lookup_records,
        };
        Some(result)
    }
}

impl<'a> ChainedClassSequenceRule<'a> {
    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of backtrack-sequence classes
    pub fn backtrack_sequence(&self) -> &[BigEndian<u16>] {
        &self.backtrack_sequence
    }

    /// Total number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of input sequence classes, beginning with the second
    /// glyph position
    pub fn input_sequence(&self) -> &[BigEndian<u16>] {
        &self.input_sequence
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of lookahead-sequence classes
    pub fn lookahead_sequence(&self) -> &[BigEndian<u16>] {
        &self.lookahead_sequence
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

/// [Chained Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-3-coverage-based-glyph-contexts)
pub struct ChainedSequenceContextFormat3<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    backtrack_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    input_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    input_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    lookahead_glyph_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    lookahead_coverage_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    seq_lookup_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    seq_lookup_records: zerocopy::LayoutVerified<&'a [u8], [SequenceLookupRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContextFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (backtrack_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_backtrack_glyph_count = backtrack_glyph_count.get();
        let (backtrack_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_backtrack_glyph_count as usize,
            )?;
        let (input_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_input_glyph_count = input_glyph_count.get();
        let (input_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_input_glyph_count as usize,
            )?;
        let (lookahead_glyph_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_lookahead_glyph_count = lookahead_glyph_count.get();
        let (lookahead_coverage_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_lookahead_glyph_count as usize,
            )?;
        let (seq_lookup_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_seq_lookup_count = seq_lookup_count.get();
        let (seq_lookup_records, bytes) =
            zerocopy::LayoutVerified::<_, [SequenceLookupRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_seq_lookup_count as usize,
            )?;
        let _bytes = bytes;
        let result = ChainedSequenceContextFormat3 {
            format,
            backtrack_glyph_count,
            backtrack_coverage_offsets,
            input_glyph_count,
            input_coverage_offsets,
            lookahead_glyph_count,
            lookahead_coverage_offsets,
            seq_lookup_count,
            seq_lookup_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ChainedSequenceContextFormat3<'a> {
    /// Format identifier: format = 3
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Number of glyphs in the backtrack sequence
    pub fn backtrack_glyph_count(&self) -> u16 {
        self.backtrack_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the backtrack sequence
    pub fn backtrack_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.backtrack_coverage_offsets
    }

    pub fn backtrack_coverage(&self) -> impl Iterator<Item = Option<CoverageTable>> + '_ {
        self.backtrack_coverage_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }

    /// Number of glyphs in the input sequence
    pub fn input_glyph_count(&self) -> u16 {
        self.input_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the input sequence
    pub fn input_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.input_coverage_offsets
    }

    pub fn input_coverage(&self) -> impl Iterator<Item = Option<CoverageTable>> + '_ {
        self.input_coverage_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }

    /// Number of glyphs in the lookahead sequence
    pub fn lookahead_glyph_count(&self) -> u16 {
        self.lookahead_glyph_count.get()
    }

    /// Array of offsets to coverage tables for the lookahead sequence
    pub fn lookahead_coverage_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.lookahead_coverage_offsets
    }

    pub fn lookahead_coverage(&self) -> impl Iterator<Item = Option<CoverageTable>> + '_ {
        self.lookahead_coverage_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }

    /// Number of SequenceLookupRecords
    pub fn seq_lookup_count(&self) -> u16 {
        self.seq_lookup_count.get()
    }

    /// Array of SequenceLookupRecords
    pub fn seq_lookup_records(&self) -> &[SequenceLookupRecord] {
        &self.seq_lookup_records
    }
}

impl<'a> font_types::OffsetHost<'a> for ChainedSequenceContextFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum ChainedSequenceContext<'a> {
    Format1(ChainedSequenceContextFormat1<'a>),
    Format2(ChainedSequenceContextFormat2<'a>),
    Format3(ChainedSequenceContextFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for ChainedSequenceContext<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(ChainedSequenceContext)
                    );
                }
                None
            }
        }
    }
}

/// [Device Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#device-and-variationindex-tables)
pub struct Device<'a> {
    start_size: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    end_size: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    delta_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    delta_value: zerocopy::LayoutVerified<&'a [u8], [BigEndian<u16>]>,
}

impl<'a> font_types::FontRead<'a> for Device<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (start_size, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (end_size, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (delta_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (delta_value, bytes) = (
            zerocopy::LayoutVerified::<_, [BigEndian<u16>]>::new_slice_unaligned(bytes)?,
            0,
        );
        let _bytes = bytes;
        let result = Device {
            start_size,
            end_size,
            delta_format,
            delta_value,
        };
        Some(result)
    }
}

impl<'a> Device<'a> {
    /// Smallest size to correct, in ppem
    pub fn start_size(&self) -> u16 {
        self.start_size.get()
    }

    /// Largest size to correct, in ppem
    pub fn end_size(&self) -> u16 {
        self.end_size.get()
    }

    /// Format of deltaValue array data: 0x0001, 0x0002, or 0x0003
    pub fn delta_format(&self) -> u16 {
        self.delta_format.get()
    }

    /// Array of compressed data
    pub fn delta_value(&self) -> &[BigEndian<u16>] {
        &self.delta_value
    }
}

/// Variation index table
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct VariationIndex {
    /// A delta-set outer index — used to select an item variation
    /// data subtable within the item variation store.
    pub delta_set_outer_index: BigEndian<u16>,
    /// A delta-set inner index — used to select a delta-set row
    /// within an item variation data subtable.
    pub delta_set_inner_index: BigEndian<u16>,
    /// Format, = 0x8000
    pub delta_format: BigEndian<u16>,
}

impl VariationIndex {
    /// A delta-set outer index — used to select an item variation
    /// data subtable within the item variation store.
    pub fn delta_set_outer_index(&self) -> u16 {
        self.delta_set_outer_index.get()
    }

    /// A delta-set inner index — used to select a delta-set row
    /// within an item variation data subtable.
    pub fn delta_set_inner_index(&self) -> u16 {
        self.delta_set_inner_index.get()
    }

    /// Format, = 0x8000
    pub fn delta_format(&self) -> u16 {
        self.delta_format.get()
    }
}

/// [FeatureVariations Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#featurevariations-table)
pub struct FeatureVariations<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feature_variation_record_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u32>>,
    feature_variation_records: zerocopy::LayoutVerified<&'a [u8], [FeatureVariationRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureVariations<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_variation_record_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u32>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_feature_variation_record_count = feature_variation_record_count.get();
        let (feature_variation_records, bytes) = zerocopy::LayoutVerified::<
            _,
            [FeatureVariationRecord],
        >::new_slice_unaligned_from_prefix(
            bytes,
            __resolved_feature_variation_record_count as usize,
        )?;
        let _bytes = bytes;
        let result = FeatureVariations {
            major_version,
            minor_version,
            feature_variation_record_count,
            feature_variation_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureVariations<'a> {
    /// Major version of the FeatureVariations table — set to 1.
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the FeatureVariations table — set to 0.
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Number of feature variation records.
    pub fn feature_variation_record_count(&self) -> u32 {
        self.feature_variation_record_count.get()
    }

    /// Array of feature variation records.
    pub fn feature_variation_records(&self) -> &[FeatureVariationRecord] {
        &self.feature_variation_records
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureVariations<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [FeatureVariations]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureVariationRecord {
    /// Offset to a condition set table, from beginning of
    /// FeatureVariations table.
    pub condition_set_offset: BigEndian<Offset32>,
    /// Offset to a feature table substitution table, from beginning of
    /// the FeatureVariations table.
    pub feature_table_substitution_offset: BigEndian<Offset32>,
}

impl FeatureVariationRecord {
    /// Offset to a condition set table, from beginning of
    /// FeatureVariations table.
    pub fn condition_set_offset(&self) -> Offset32 {
        self.condition_set_offset.get()
    }

    /// Offset to a feature table substitution table, from beginning of
    /// the FeatureVariations table.
    pub fn feature_table_substitution_offset(&self) -> Offset32 {
        self.feature_table_substitution_offset.get()
    }
}

/// [ConditionSet Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#conditionset-table)
pub struct ConditionSet<'a> {
    condition_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    condition_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset32>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ConditionSet<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (condition_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_condition_count = condition_count.get();
        let (condition_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset32>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_condition_count as usize,
            )?;
        let _bytes = bytes;
        let result = ConditionSet {
            condition_count,
            condition_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ConditionSet<'a> {
    /// Number of conditions for this condition set.
    pub fn condition_count(&self) -> u16 {
        self.condition_count.get()
    }

    /// Array of offsets to condition tables, from beginning of the
    /// ConditionSet table.
    pub fn condition_offsets(&self) -> &[BigEndian<Offset32>] {
        &self.condition_offsets
    }

    pub fn condition(&self) -> impl Iterator<Item = Option<ConditionFormat1>> + '_ {
        self.condition_offsets()
            .iter()
            .map(|item| item.get().read(self.bytes()))
    }
}

impl<'a> font_types::OffsetHost<'a> for ConditionSet<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Condition Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#condition-table-format-1-font-variation-axis-range): Font Variation Axis Range
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct ConditionFormat1 {
    /// Format, = 1
    pub format: BigEndian<u16>,
    /// Index (zero-based) for the variation axis within the 'fvar'
    /// table.
    pub axis_index: BigEndian<u16>,
    /// Minimum value of the font variation instances that satisfy this
    /// condition.
    pub filter_range_min_value: BigEndian<F2Dot14>,
    /// Maximum value of the font variation instances that satisfy this
    /// condition.
    pub filter_range_max_value: BigEndian<F2Dot14>,
}

impl ConditionFormat1 {
    /// Format, = 1
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// Index (zero-based) for the variation axis within the 'fvar'
    /// table.
    pub fn axis_index(&self) -> u16 {
        self.axis_index.get()
    }

    /// Minimum value of the font variation instances that satisfy this
    /// condition.
    pub fn filter_range_min_value(&self) -> F2Dot14 {
        self.filter_range_min_value.get()
    }

    /// Maximum value of the font variation instances that satisfy this
    /// condition.
    pub fn filter_range_max_value(&self) -> F2Dot14 {
        self.filter_range_max_value.get()
    }
}

/// [FeatureTableSubstitution Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#featuretablesubstitution-table)
pub struct FeatureTableSubstitution<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    substitution_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    substitutions: zerocopy::LayoutVerified<&'a [u8], [FeatureTableSubstitutionRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for FeatureTableSubstitution<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (substitution_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_substitution_count = substitution_count.get();
        let (substitutions , bytes) = zerocopy :: LayoutVerified :: < _ , [FeatureTableSubstitutionRecord] > :: new_slice_unaligned_from_prefix (bytes , __resolved_substitution_count as usize) ? ;
        let _bytes = bytes;
        let result = FeatureTableSubstitution {
            major_version,
            minor_version,
            substitution_count,
            substitutions,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> FeatureTableSubstitution<'a> {
    /// Major version of the feature table substitution table — set
    /// to 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the feature table substitution table — set
    /// to 0.
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Number of feature table substitution records.
    pub fn substitution_count(&self) -> u16 {
        self.substitution_count.get()
    }

    /// Array of feature table substitution records.
    pub fn substitutions(&self) -> &[FeatureTableSubstitutionRecord] {
        &self.substitutions
    }
}

impl<'a> font_types::OffsetHost<'a> for FeatureTableSubstitution<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Used in [FeatureTableSubstitution]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FeatureTableSubstitutionRecord {
    /// The feature table index to match.
    pub feature_index: BigEndian<u16>,
    /// Offset to an alternate feature table, from start of the
    /// FeatureTableSubstitution table.
    pub alternate_feature_offset: BigEndian<Offset32>,
}

impl FeatureTableSubstitutionRecord {
    /// The feature table index to match.
    pub fn feature_index(&self) -> u16 {
        self.feature_index.get()
    }

    /// Offset to an alternate feature table, from start of the
    /// FeatureTableSubstitution table.
    pub fn alternate_feature_offset(&self) -> Offset32 {
        self.alternate_feature_offset.get()
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct SizeParams {
    /// The first value represents the design size in 720/inch units (decipoints).
    ///
    /// The design size entry must be non-zero. When there is a design size but
    /// no recommended size range, the rest of the array will consist of zeros.
    pub design_size: BigEndian<u16>,
    /// The second value has no independent meaning, but serves as an identifier that associates fonts in a subfamily.
    ///
    /// All fonts which share a Typographic or Font Family name and which differ
    /// only by size range shall have the same subfamily value, and no fonts
    /// which differ in weight or style shall have the same subfamily value.
    /// If this value is zero, the remaining fields in the array will be ignored.
    pub identifier: BigEndian<u16>,
    /// The third value enables applications to use a single name for the subfamily identified by the second value.
    ///
    /// If the preceding value is non-zero, this value must be set in the range
    /// 256 – 32767 (inclusive). It records the value of a field in the 'name'
    /// table, which must contain English-language strings encoded in Windows
    /// Unicode and Macintosh Roman, and may contain additional strings localized
    /// to other scripts and languages. Each of these strings is the name
    /// an application should use, in combination with the family name, to
    /// represent the subfamily in a menu. Applications will choose the
    /// appropriate version based on their selection criteria.
    pub name_entry: BigEndian<u16>,
    /// The fourth and fifth values represent the small end of the recommended
    /// usage range (exclusive) and the large end of the recommended usage range
    /// (inclusive), stored in 720/inch units (decipoints).
    ///
    /// Ranges must not overlap, and should generally be contiguous.
    pub range_start: BigEndian<u16>,
    pub range_end: BigEndian<u16>,
}

impl SizeParams {
    /// The first value represents the design size in 720/inch units (decipoints).
    ///
    /// The design size entry must be non-zero. When there is a design size but
    /// no recommended size range, the rest of the array will consist of zeros.
    pub fn design_size(&self) -> u16 {
        self.design_size.get()
    }

    /// The second value has no independent meaning, but serves as an identifier that associates fonts in a subfamily.
    ///
    /// All fonts which share a Typographic or Font Family name and which differ
    /// only by size range shall have the same subfamily value, and no fonts
    /// which differ in weight or style shall have the same subfamily value.
    /// If this value is zero, the remaining fields in the array will be ignored.
    pub fn identifier(&self) -> u16 {
        self.identifier.get()
    }

    /// The third value enables applications to use a single name for the subfamily identified by the second value.
    ///
    /// If the preceding value is non-zero, this value must be set in the range
    /// 256 – 32767 (inclusive). It records the value of a field in the 'name'
    /// table, which must contain English-language strings encoded in Windows
    /// Unicode and Macintosh Roman, and may contain additional strings localized
    /// to other scripts and languages. Each of these strings is the name
    /// an application should use, in combination with the family name, to
    /// represent the subfamily in a menu. Applications will choose the
    /// appropriate version based on their selection criteria.
    pub fn name_entry(&self) -> u16 {
        self.name_entry.get()
    }

    /// The fourth and fifth values represent the small end of the recommended
    /// usage range (exclusive) and the large end of the recommended usage range
    /// (inclusive), stored in 720/inch units (decipoints).
    ///
    /// Ranges must not overlap, and should generally be contiguous.
    pub fn range_start(&self) -> u16 {
        self.range_start.get()
    }

    pub fn range_end(&self) -> u16 {
        self.range_end.get()
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct StylisticSetParams {
    pub version: BigEndian<u16>,
    /// The 'name' table name ID that specifies a string (or strings, for
    /// multiple languages) for a user-interface label for this feature.
    ///
    /// The value of uiLabelNameId is expected to be in the font-specific name
    /// ID range (256-32767), though that is not a requirement in this Feature
    /// Parameters specification. The user-interface label for the feature can
    /// be provided in multiple languages. An English string should be included
    /// as a fallback. The string should be kept to a minimal length to fit
    /// comfortably with different application interfaces.
    pub ui_name_id: BigEndian<u16>,
}

impl StylisticSetParams {
    pub fn version(&self) -> u16 {
        self.version.get()
    }

    /// The 'name' table name ID that specifies a string (or strings, for
    /// multiple languages) for a user-interface label for this feature.
    ///
    /// The value of uiLabelNameId is expected to be in the font-specific name
    /// ID range (256-32767), though that is not a requirement in this Feature
    /// Parameters specification. The user-interface label for the feature can
    /// be provided in multiple languages. An English string should be included
    /// as a fallback. The string should be kept to a minimal length to fit
    /// comfortably with different application interfaces.
    pub fn ui_name_id(&self) -> u16 {
        self.ui_name_id.get()
    }
}

/// featureParams for ['cv01'-'cv99'](https://docs.microsoft.com/en-us/typography/opentype/spec/features_ae#cv01-cv99)
pub struct CharacterVariantParams<'a> {
    format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feat_ui_label_name_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    feat_ui_tooltip_text_name_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    sample_text_name_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    num_named_parameters: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    first_param_ui_label_name_id: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    char_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    character: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Uint24>]>,
}

impl<'a> font_types::FontRead<'a> for CharacterVariantParams<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feat_ui_label_name_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (feat_ui_tooltip_text_name_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (sample_text_name_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (num_named_parameters, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (first_param_ui_label_name_id, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (char_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_char_count = char_count.get();
        let (character, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Uint24>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_char_count as usize,
            )?;
        let _bytes = bytes;
        let result = CharacterVariantParams {
            format,
            feat_ui_label_name_id,
            feat_ui_tooltip_text_name_id,
            sample_text_name_id,
            num_named_parameters,
            first_param_ui_label_name_id,
            char_count,
            character,
        };
        Some(result)
    }
}

impl<'a> CharacterVariantParams<'a> {
    /// Format number is set to 0.
    pub fn format(&self) -> u16 {
        self.format.get()
    }

    /// The 'name' table name ID that specifies a string (or strings,
    /// for multiple languages) for a user-interface label for this
    /// feature. (May be NULL.)
    pub fn feat_ui_label_name_id(&self) -> u16 {
        self.feat_ui_label_name_id.get()
    }

    /// The 'name' table name ID that specifies a string (or strings,
    /// for multiple languages) that an application can use for tooltip
    /// text for this feature. (May be NULL.)
    pub fn feat_ui_tooltip_text_name_id(&self) -> u16 {
        self.feat_ui_tooltip_text_name_id.get()
    }

    /// The 'name' table name ID that specifies sample text that
    /// illustrates the effect of this feature. (May be NULL.)
    pub fn sample_text_name_id(&self) -> u16 {
        self.sample_text_name_id.get()
    }

    /// Number of named parameters. (May be zero.)
    pub fn num_named_parameters(&self) -> u16 {
        self.num_named_parameters.get()
    }

    /// The first 'name' table name ID used to specify strings for
    /// user-interface labels for the feature parameters. (Must be zero
    /// if numParameters is zero.)
    pub fn first_param_ui_label_name_id(&self) -> u16 {
        self.first_param_ui_label_name_id.get()
    }

    /// The count of characters for which this feature provides glyph
    /// variants. (May be zero.)
    pub fn char_count(&self) -> u16 {
        self.char_count.get()
    }

    /// The Unicode Scalar Value of the characters for which this
    /// feature provides glyph variants.
    pub fn character(&self) -> &[BigEndian<Uint24>] {
        &self.character
    }
}

fn minus_one(inp: u16) -> usize {
    inp.saturating_sub(1) as usize
}

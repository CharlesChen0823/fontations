// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use font_types::*;

/// [`maxp`](https://docs.microsoft.com/en-us/typography/opentype/spec/maxp)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct Maxp0_5 {
    /// 0x00005000 for version 0.5
    pub version: BigEndian<Version16Dot16>,
    /// The number of glyphs in the font.
    pub num_glyphs: BigEndian<u16>,
}

impl Maxp0_5 {
    /// 0x00005000 for version 0.5
    pub fn version(&self) -> Version16Dot16 {
        self.version.get()
    }

    /// The number of glyphs in the font.
    pub fn num_glyphs(&self) -> u16 {
        self.num_glyphs.get()
    }
}

/// [`maxp`](https://docs.microsoft.com/en-us/typography/opentype/spec/maxp)
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct Maxp1_0 {
    /// 0x00010000 for version 1.0.
    pub version: BigEndian<Version16Dot16>,
    /// The number of glyphs in the font.
    pub num_glyphs: BigEndian<u16>,
    /// Maximum points in a non-composite glyph.
    pub max_points: BigEndian<u16>,
    /// Maximum contours in a non-composite glyph.
    pub max_contours: BigEndian<u16>,
    /// Maximum points in a composite glyph.
    pub max_composite_points: BigEndian<u16>,
    /// Maximum contours in a composite glyph.
    pub max_composite_contours: BigEndian<u16>,
    /// 1 if instructions do not use the twilight zone (Z0), or 2 if
    /// instructions do use Z0; should be set to 2 in most cases.
    pub max_zones: BigEndian<u16>,
    /// Maximum points used in Z0.
    pub max_twilight_points: BigEndian<u16>,
    /// Number of Storage Area locations.
    pub max_storage: BigEndian<u16>,
    /// Number of FDEFs, equal to the highest function number + 1.
    pub max_function_defs: BigEndian<u16>,
    /// Number of IDEFs.
    pub max_instruction_defs: BigEndian<u16>,
    /// Maximum stack depth across Font Program ('fpgm' table), CVT
    /// Program ('prep' table) and all glyph instructions (in the
    /// 'glyf' table).
    pub max_stack_elements: BigEndian<u16>,
    /// Maximum byte count for glyph instructions.
    pub max_size_of_instructions: BigEndian<u16>,
    /// Maximum number of components referenced at “top level” for
    /// any composite glyph.
    pub max_component_elements: BigEndian<u16>,
    /// Maximum levels of recursion; 1 for simple components.
    pub max_component_depth: BigEndian<u16>,
}

impl Maxp1_0 {
    /// 0x00010000 for version 1.0.
    pub fn version(&self) -> Version16Dot16 {
        self.version.get()
    }

    /// The number of glyphs in the font.
    pub fn num_glyphs(&self) -> u16 {
        self.num_glyphs.get()
    }

    /// Maximum points in a non-composite glyph.
    pub fn max_points(&self) -> u16 {
        self.max_points.get()
    }

    /// Maximum contours in a non-composite glyph.
    pub fn max_contours(&self) -> u16 {
        self.max_contours.get()
    }

    /// Maximum points in a composite glyph.
    pub fn max_composite_points(&self) -> u16 {
        self.max_composite_points.get()
    }

    /// Maximum contours in a composite glyph.
    pub fn max_composite_contours(&self) -> u16 {
        self.max_composite_contours.get()
    }

    /// 1 if instructions do not use the twilight zone (Z0), or 2 if
    /// instructions do use Z0; should be set to 2 in most cases.
    pub fn max_zones(&self) -> u16 {
        self.max_zones.get()
    }

    /// Maximum points used in Z0.
    pub fn max_twilight_points(&self) -> u16 {
        self.max_twilight_points.get()
    }

    /// Number of Storage Area locations.
    pub fn max_storage(&self) -> u16 {
        self.max_storage.get()
    }

    /// Number of FDEFs, equal to the highest function number + 1.
    pub fn max_function_defs(&self) -> u16 {
        self.max_function_defs.get()
    }

    /// Number of IDEFs.
    pub fn max_instruction_defs(&self) -> u16 {
        self.max_instruction_defs.get()
    }

    /// Maximum stack depth across Font Program ('fpgm' table), CVT
    /// Program ('prep' table) and all glyph instructions (in the
    /// 'glyf' table).
    pub fn max_stack_elements(&self) -> u16 {
        self.max_stack_elements.get()
    }

    /// Maximum byte count for glyph instructions.
    pub fn max_size_of_instructions(&self) -> u16 {
        self.max_size_of_instructions.get()
    }

    /// Maximum number of components referenced at “top level” for
    /// any composite glyph.
    pub fn max_component_elements(&self) -> u16 {
        self.max_component_elements.get()
    }

    /// Maximum levels of recursion; 1 for simple components.
    pub fn max_component_depth(&self) -> u16 {
        self.max_component_depth.get()
    }
}

pub enum Maxp {
    Version0_5(Maxp0_5),
    Version1_0(Maxp1_0),
}

impl<'a> font_types::FontRead<'a> for Maxp {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        const _: Version16Dot16 = Version16Dot16::VERSION_0_5;
        const _: Version16Dot16 = Version16Dot16::VERSION_1_0;
        let version: BigEndian<Version16Dot16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            Version16Dot16::VERSION_0_5 => {
                Some(Self::Version0_5(font_types::FontRead::read(bytes)?))
            }
            Version16Dot16::VERSION_1_0 => {
                Some(Self::Version1_0(font_types::FontRead::read(bytes)?))
            }
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(Maxp)
                    );
                }
                None
            }
        }
    }
}

impl Maxp {
    /// Maximum levels of recursion; 1 for simple components.
    pub fn max_component_depth(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_component_depth()),
        }
    }

    /// Maximum number of components referenced at “top level” for
    /// any composite glyph.
    pub fn max_component_elements(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_component_elements()),
        }
    }

    /// Maximum contours in a composite glyph.
    pub fn max_composite_contours(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_composite_contours()),
        }
    }

    /// Maximum points in a composite glyph.
    pub fn max_composite_points(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_composite_points()),
        }
    }

    /// Maximum contours in a non-composite glyph.
    pub fn max_contours(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_contours()),
        }
    }

    /// Number of FDEFs, equal to the highest function number + 1.
    pub fn max_function_defs(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_function_defs()),
        }
    }

    /// Number of IDEFs.
    pub fn max_instruction_defs(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_instruction_defs()),
        }
    }

    /// Maximum points in a non-composite glyph.
    pub fn max_points(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_points()),
        }
    }

    /// Maximum byte count for glyph instructions.
    pub fn max_size_of_instructions(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_size_of_instructions()),
        }
    }

    /// Maximum stack depth across Font Program ('fpgm' table), CVT
    /// Program ('prep' table) and all glyph instructions (in the
    /// 'glyf' table).
    pub fn max_stack_elements(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_stack_elements()),
        }
    }

    /// Number of Storage Area locations.
    pub fn max_storage(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_storage()),
        }
    }

    /// Maximum points used in Z0.
    pub fn max_twilight_points(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_twilight_points()),
        }
    }

    /// 1 if instructions do not use the twilight zone (Z0), or 2 if
    /// instructions do use Z0; should be set to 2 in most cases.
    pub fn max_zones(&self) -> Option<u16> {
        match self {
            Self::Version0_5(_inner) => None,
            Self::Version1_0(_inner) => Some(_inner.max_zones()),
        }
    }

    /// The number of glyphs in the font.
    pub fn num_glyphs(&self) -> u16 {
        match self {
            Self::Version0_5(_inner) => _inner.num_glyphs(),
            Self::Version1_0(_inner) => _inner.num_glyphs(),
        }
    }

    /// 0x00005000 for version 0.5
    pub fn version(&self) -> Version16Dot16 {
        match self {
            Self::Version0_5(_inner) => _inner.version(),
            Self::Version1_0(_inner) => _inner.version(),
        }
    }
}

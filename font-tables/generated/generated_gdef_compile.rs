// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

use super::GlyphClassDef;

#[allow(unused_imports)]
use crate::compile::*;
use crate::layout::compile::ClassDef;
use crate::layout::compile::CoverageTable;

#[allow(unused_imports)]
use font_types::*;

#[derive(Debug, PartialEq)]
pub struct Gdef1_0 {
    pub glyph_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
    pub attach_list_offset: NullableOffsetMarker<Offset16, AttachList>,
    pub lig_caret_list_offset: NullableOffsetMarker<Offset16, LigCaretList>,
    pub mark_attach_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
}

impl ToOwnedObj for super::Gdef1_0<'_> {
    type Owned = Gdef1_0;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(Gdef1_0 {
            glyph_class_def_offset: NullableOffsetMarker::new(
                self.glyph_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            attach_list_offset: NullableOffsetMarker::new(
                self.attach_list_offset()
                    .read::<super::AttachList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lig_caret_list_offset: NullableOffsetMarker::new(
                self.lig_caret_list_offset()
                    .read::<super::LigCaretList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            mark_attach_class_def_offset: NullableOffsetMarker::new(
                self.mark_attach_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl ToOwnedTable for super::Gdef1_0<'_> {}

impl FontWrite for Gdef1_0 {
    fn write_into(&self, writer: &mut TableWriter) {
        let major_version: u16 = 1;
        major_version.write_into(writer);
        let minor_version: u16 = 0;
        minor_version.write_into(writer);
        self.glyph_class_def_offset.write_into(writer);
        self.attach_list_offset.write_into(writer);
        self.lig_caret_list_offset.write_into(writer);
        self.mark_attach_class_def_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct Gdef1_2 {
    pub glyph_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
    pub attach_list_offset: NullableOffsetMarker<Offset16, AttachList>,
    pub lig_caret_list_offset: NullableOffsetMarker<Offset16, LigCaretList>,
    pub mark_attach_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
    pub mark_glyph_sets_def_offset: NullableOffsetMarker<Offset16, MarkGlyphSets>,
}

impl ToOwnedObj for super::Gdef1_2<'_> {
    type Owned = Gdef1_2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(Gdef1_2 {
            glyph_class_def_offset: NullableOffsetMarker::new(
                self.glyph_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            attach_list_offset: NullableOffsetMarker::new(
                self.attach_list_offset()
                    .read::<super::AttachList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lig_caret_list_offset: NullableOffsetMarker::new(
                self.lig_caret_list_offset()
                    .read::<super::LigCaretList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            mark_attach_class_def_offset: NullableOffsetMarker::new(
                self.mark_attach_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            mark_glyph_sets_def_offset: NullableOffsetMarker::new(
                self.mark_glyph_sets_def_offset()
                    .read::<super::MarkGlyphSets>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl ToOwnedTable for super::Gdef1_2<'_> {}

impl FontWrite for Gdef1_2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let major_version: u16 = 1;
        major_version.write_into(writer);
        let minor_version: u16 = 2;
        minor_version.write_into(writer);
        self.glyph_class_def_offset.write_into(writer);
        self.attach_list_offset.write_into(writer);
        self.lig_caret_list_offset.write_into(writer);
        self.mark_attach_class_def_offset.write_into(writer);
        self.mark_glyph_sets_def_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct Gdef1_3 {
    pub glyph_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
    pub attach_list_offset: NullableOffsetMarker<Offset16, AttachList>,
    pub lig_caret_list_offset: NullableOffsetMarker<Offset16, LigCaretList>,
    pub mark_attach_class_def_offset: NullableOffsetMarker<Offset16, ClassDef>,
    pub mark_glyph_sets_def_offset: NullableOffsetMarker<Offset16, MarkGlyphSets>,
    pub item_var_store_offset: NullableOffsetMarker<Offset32, ClassDef>,
}

impl ToOwnedObj for super::Gdef1_3<'_> {
    type Owned = Gdef1_3;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(Gdef1_3 {
            glyph_class_def_offset: NullableOffsetMarker::new(
                self.glyph_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            attach_list_offset: NullableOffsetMarker::new(
                self.attach_list_offset()
                    .read::<super::AttachList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lig_caret_list_offset: NullableOffsetMarker::new(
                self.lig_caret_list_offset()
                    .read::<super::LigCaretList>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            mark_attach_class_def_offset: NullableOffsetMarker::new(
                self.mark_attach_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            mark_glyph_sets_def_offset: NullableOffsetMarker::new(
                self.mark_glyph_sets_def_offset()
                    .read::<super::MarkGlyphSets>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            item_var_store_offset: NullableOffsetMarker::new(
                self.item_var_store_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl ToOwnedTable for super::Gdef1_3<'_> {}

impl FontWrite for Gdef1_3 {
    fn write_into(&self, writer: &mut TableWriter) {
        let major_version: u16 = 1;
        major_version.write_into(writer);
        let minor_version: u16 = 3;
        minor_version.write_into(writer);
        self.glyph_class_def_offset.write_into(writer);
        self.attach_list_offset.write_into(writer);
        self.lig_caret_list_offset.write_into(writer);
        self.mark_attach_class_def_offset.write_into(writer);
        self.mark_glyph_sets_def_offset.write_into(writer);
        self.item_var_store_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum Gdef {
    Gdef1_0(Gdef1_0),
    Gdef1_2(Gdef1_2),
    Gdef1_3(Gdef1_3),
}

impl ToOwnedObj for super::Gdef<'_> {
    type Owned = Gdef;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::Gdef::Gdef1_0(item) => Gdef::Gdef1_0(item.to_owned_obj(offset_data)?),
            super::Gdef::Gdef1_2(item) => Gdef::Gdef1_2(item.to_owned_obj(offset_data)?),
            super::Gdef::Gdef1_3(item) => Gdef::Gdef1_3(item.to_owned_obj(offset_data)?),
        })
    }
}

impl ToOwnedTable for super::Gdef<'_> {}

impl FontWrite for Gdef {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Gdef1_0(item) => item.write_into(writer),
            Self::Gdef1_2(item) => item.write_into(writer),
            Self::Gdef1_3(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct AttachPoint {
    pub point_indices: Vec<u16>,
}

impl ToOwnedObj for super::AttachPoint<'_> {
    type Owned = AttachPoint;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(AttachPoint {
            point_indices: self
                .point_indices()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for AttachPoint {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.point_indices.len())
            .unwrap()
            .write_into(writer);
        self.point_indices.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct LigCaretList {
    pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
    pub lig_glyph_offsets: Vec<OffsetMarker<Offset16, LigGlyph>>,
}

impl ToOwnedObj for super::LigCaretList<'_> {
    type Owned = LigCaretList;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(LigCaretList {
            coverage_offset: OffsetMarker::new_maybe_null(
                self.coverage_offset()
                    .read::<super::CoverageTable>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lig_glyph_offsets: self
                .lig_glyph_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::LigGlyph>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::LigCaretList<'_> {}

impl FontWrite for LigCaretList {
    fn write_into(&self, writer: &mut TableWriter) {
        self.coverage_offset.write_into(writer);
        u16::try_from(self.lig_glyph_offsets.len())
            .unwrap()
            .write_into(writer);
        self.lig_glyph_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct LigGlyph {
    pub caret_value_offsets: Vec<OffsetMarker<Offset16, CaretValue>>,
}

impl ToOwnedObj for super::LigGlyph<'_> {
    type Owned = LigGlyph;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(LigGlyph {
            caret_value_offsets: self
                .caret_value_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CaretValue>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::LigGlyph<'_> {}

impl FontWrite for LigGlyph {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.caret_value_offsets.len())
            .unwrap()
            .write_into(writer);
        self.caret_value_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum CaretValue {
    Format1(CaretValueFormat1),
    Format2(CaretValueFormat2),
    Format3(CaretValueFormat3),
}

impl ToOwnedObj for super::CaretValue<'_> {
    type Owned = CaretValue;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::CaretValue::Format1(item) => {
                CaretValue::Format1(item.to_owned_obj(offset_data)?)
            }
            super::CaretValue::Format2(item) => {
                CaretValue::Format2(item.to_owned_obj(offset_data)?)
            }
            super::CaretValue::Format3(item) => {
                CaretValue::Format3(item.to_owned_obj(offset_data)?)
            }
        })
    }
}

impl FontWrite for CaretValue {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Format1(item) => item.write_into(writer),
            Self::Format2(item) => item.write_into(writer),
            Self::Format3(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct CaretValueFormat1 {
    pub coordinate: i16,
}

impl ToOwnedObj for super::CaretValueFormat1 {
    type Owned = CaretValueFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(CaretValueFormat1 {
            coordinate: self.coordinate(),
        })
    }
}

impl FontWrite for CaretValueFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let caret_value_format: u16 = 1;
        caret_value_format.write_into(writer);
        self.coordinate.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct CaretValueFormat2 {
    pub caret_value_point_index: u16,
}

impl ToOwnedObj for super::CaretValueFormat2 {
    type Owned = CaretValueFormat2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(CaretValueFormat2 {
            caret_value_point_index: self.caret_value_point_index(),
        })
    }
}

impl FontWrite for CaretValueFormat2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let caret_value_format: u16 = 2;
        caret_value_format.write_into(writer);
        self.caret_value_point_index.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct MarkGlyphSets {
    pub coverage_offsets: Vec<OffsetMarker<Offset32, CoverageTable>>,
}

impl ToOwnedObj for super::MarkGlyphSets<'_> {
    type Owned = MarkGlyphSets;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(MarkGlyphSets {
            coverage_offsets: self
                .coverage_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CoverageTable>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::MarkGlyphSets<'_> {}

impl FontWrite for MarkGlyphSets {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 1;
        format.write_into(writer);
        u16::try_from(self.coverage_offsets.len())
            .unwrap()
            .write_into(writer);
        self.coverage_offsets.write_into(writer);
    }
}

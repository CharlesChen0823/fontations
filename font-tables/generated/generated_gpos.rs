// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

use crate::layout::ClassDef;
use crate::layout::CoverageTable;
use crate::layout::FeatureList;
use crate::layout::FeatureVariations;
use crate::layout::ScriptList;
use crate::tables::gpos::BaseArray;
use crate::tables::gpos::PairValueRecord;
use crate::tables::gpos::PositionLookupList;
use crate::tables::gpos::ValueRecord;
use font_types::*;

/// [GPOS Version 1.0](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#gpos-header)
pub struct Gpos1_0<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookup_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gpos1_0<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (script_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gpos1_0 {
            major_version,
            minor_version,
            script_list_offset,
            feature_list_offset,
            lookup_list_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gpos1_0<'a> {
    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GPOS table, = 0
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        self.script_list_offset.get()
    }

    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        self.feature_list_offset.get()
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        self.lookup_list_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos1_0<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [GPOS Version 1.1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#gpos-header)
pub struct Gpos1_1<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookup_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_variations_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset32>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gpos1_1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (script_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_variations_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset32>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gpos1_1 {
            major_version,
            minor_version,
            script_list_offset,
            feature_list_offset,
            lookup_list_offset,
            feature_variations_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gpos1_1<'a> {
    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GPOS table, = 1
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        self.script_list_offset.get()
    }

    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        self.feature_list_offset.get()
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        self.lookup_list_offset.get()
    }

    /// Offset to FeatureVariations table, from beginning of GPOS table
    /// (may be NULL)
    pub fn feature_variations_offset(&self) -> Offset32 {
        self.feature_variations_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos1_1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum Gpos<'a> {
    Version1_0(Gpos1_0<'a>),
    Version1_1(Gpos1_1<'a>),
}

impl<'a> font_types::FontRead<'a> for Gpos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        const _: MajorMinor = MajorMinor::VERSION_1_0;
        const _: MajorMinor = MajorMinor::VERSION_1_1;
        let version: BigEndian<MajorMinor> = font_types::FontRead::read(bytes)?;
        match version.get() {
            MajorMinor::VERSION_1_0 => Some(Self::Version1_0(font_types::FontRead::read(bytes)?)),
            MajorMinor::VERSION_1_1 => Some(Self::Version1_1(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(Gpos)
                    );
                }
                None
            }
        }
    }
}

impl<'a> Gpos<'a> {
    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.feature_list_offset(),
            Self::Version1_1(_inner) => _inner.feature_list_offset(),
        }
    }

    /// Offset to FeatureVariations table, from beginning of GPOS table
    /// (may be NULL)
    pub fn feature_variations_offset(&self) -> Option<Offset32> {
        match self {
            Self::Version1_0(_inner) => None,
            Self::Version1_1(_inner) => Some(_inner.feature_variations_offset()),
        }
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.lookup_list_offset(),
            Self::Version1_1(_inner) => _inner.lookup_list_offset(),
        }
    }

    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        match self {
            Self::Version1_0(_inner) => _inner.major_version(),
            Self::Version1_1(_inner) => _inner.major_version(),
        }
    }

    /// Minor version of the GPOS table, = 0
    pub fn minor_version(&self) -> u16 {
        match self {
            Self::Version1_0(_inner) => _inner.minor_version(),
            Self::Version1_1(_inner) => _inner.minor_version(),
        }
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.script_list_offset(),
            Self::Version1_1(_inner) => _inner.script_list_offset(),
        }
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos<'a> {
    fn bytes(&self) -> &'a [u8] {
        match self {
            Self::Version1_0(_inner) => _inner.bytes(),
            Self::Version1_1(_inner) => _inner.bytes(),
        }
    }
}

bitflags::bitflags! { # [doc = " See [ValueRecord]"] pub struct ValueFormat : u16 { # [doc = " Includes horizontal adjustment for placement"] const X_PLACEMENT = 0x0001 ; # [doc = " Includes vertical adjustment for placement"] const Y_PLACEMENT = 0x0002 ; # [doc = " Includes horizontal adjustment for advance"] const X_ADVANCE = 0x0004 ; # [doc = " Includes vertical adjustment for advance"] const Y_ADVANCE = 0x0008 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal placement"] const X_PLACEMENT_DEVICE = 0x0010 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical placement"] const Y_PLACEMENT_DEVICE = 0x0020 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal advance"] const X_ADVANCE_DEVICE = 0x0040 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical advance"] const Y_ADVANCE_DEVICE = 0x0080 ; } }

impl font_types::Scalar for ValueFormat {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        self.bits().to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::from_bits_truncate(t)
    }
}

pub enum AnchorTable<'a> {
    Format1(AnchorFormat1),
    Format2(AnchorFormat2),
    Format3(AnchorFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for AnchorTable<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(AnchorTable)
                    );
                }
                None
            }
        }
    }
}

/// [Anchor Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-1-design-units): Design Units
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct AnchorFormat1 {
    /// Format identifier, = 1
    pub anchor_format: BigEndian<u16>,
    /// Horizontal value, in design units
    pub x_coordinate: BigEndian<i16>,
    /// Vertical value, in design units
    pub y_coordinate: BigEndian<i16>,
}

impl AnchorFormat1 {
    /// Format identifier, = 1
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }
}

/// [Anchor Table Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-2-design-units-plus-contour-point): Design Units Plus Contour Point
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct AnchorFormat2 {
    /// Format identifier, = 2
    pub anchor_format: BigEndian<u16>,
    /// Horizontal value, in design units
    pub x_coordinate: BigEndian<i16>,
    /// Vertical value, in design units
    pub y_coordinate: BigEndian<i16>,
    /// Index to glyph contour point
    pub anchor_point: BigEndian<u16>,
}

impl AnchorFormat2 {
    /// Format identifier, = 2
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }

    /// Index to glyph contour point
    pub fn anchor_point(&self) -> u16 {
        self.anchor_point.get()
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FakeDeviceTable {
    pub version: BigEndian<u16>,
}

impl FakeDeviceTable {
    pub fn version(&self) -> u16 {
        self.version.get()
    }
}

/// [Anchor Table Format 3]()https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-3-design-units-plus-device-or-variationindex-tables: Design Units Plus Device or VariationIndex Tables
pub struct AnchorFormat3<'a> {
    anchor_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    x_coordinate: zerocopy::LayoutVerified<&'a [u8], BigEndian<i16>>,
    y_coordinate: zerocopy::LayoutVerified<&'a [u8], BigEndian<i16>>,
    x_device_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    y_device_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for AnchorFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (anchor_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (x_coordinate, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<i16>>::new_unaligned_from_prefix(bytes)?;
        let (y_coordinate, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<i16>>::new_unaligned_from_prefix(bytes)?;
        let (x_device_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (y_device_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = AnchorFormat3 {
            anchor_format,
            x_coordinate,
            y_coordinate,
            x_device_offset,
            y_device_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> AnchorFormat3<'a> {
    /// Format identifier, = 3
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }

    /// Offset to Device table (non-variable font) / VariationIndex
    /// table (variable font) for X coordinate, from beginning of
    /// Anchor table (may be NULL)
    pub fn x_device_offset(&self) -> Offset16 {
        self.x_device_offset.get()
    }

    /// Offset to Device table (non-variable font) / VariationIndex
    /// table (variable font) for Y coordinate, from beginning of
    /// Anchor table (may be NULL)
    pub fn y_device_offset(&self) -> Offset16 {
        self.y_device_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for AnchorFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Mark Array Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-array-table)
pub struct MarkArray<'a> {
    mark_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_records: zerocopy::LayoutVerified<&'a [u8], [MarkRecord]>,
}

impl<'a> font_types::FontRead<'a> for MarkArray<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let (mark_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_mark_count = mark_count.get();
        let (mark_records, bytes) =
            zerocopy::LayoutVerified::<_, [MarkRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_count as usize,
            )?;
        let _bytes = bytes;
        let result = MarkArray {
            mark_count,
            mark_records,
        };
        Some(result)
    }
}

impl<'a> MarkArray<'a> {
    /// Number of MarkRecords
    pub fn mark_count(&self) -> u16 {
        self.mark_count.get()
    }

    /// Array of MarkRecords, ordered by corresponding glyphs in the
    /// associated mark Coverage table.
    pub fn mark_records(&self) -> &[MarkRecord] {
        &self.mark_records
    }
}

/// Part of [MarkArray]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct MarkRecord {
    /// Class defined for the associated mark.
    pub mark_class: BigEndian<u16>,
    /// Offset to Anchor table, from beginning of MarkArray table.
    pub mark_anchor_offset: BigEndian<Offset16>,
}

impl MarkRecord {
    /// Class defined for the associated mark.
    pub fn mark_class(&self) -> u16 {
        self.mark_class.get()
    }

    /// Offset to Anchor table, from beginning of MarkArray table.
    pub fn mark_anchor_offset(&self) -> Offset16 {
        self.mark_anchor_offset.get()
    }
}

/// [Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable): Single Adjustment Positioning Subtable
pub enum SinglePos<'a> {
    Format1(SinglePosFormat1<'a>),
    Format2(SinglePosFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for SinglePos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(SinglePos)
                    );
                }
                None
            }
        }
    }
}

/// [Single Adjustment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#single-adjustment-positioning-format-1-single-positioning-value): Single Positioning Value
pub struct SinglePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_record: ValueRecord,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SinglePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format = value_format.get();
        let (value_record, bytes) =
            font_types::FontReadWithArgs::read_with_args(bytes.get(..)?, &__resolved_value_format)?;
        let _bytes = bytes;
        let result = SinglePosFormat1 {
            pos_format,
            coverage_offset,
            value_format,
            value_record,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SinglePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of SinglePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Defines the types of data in the ValueRecord.
    pub fn value_format(&self) -> ValueFormat {
        self.value_format.get()
    }

    /// Defines positioning value(s) — applied to all glyphs in the
    /// Coverage table.
    pub fn value_record(&self) -> &ValueRecord {
        &self.value_record
    }
}

impl<'a> font_types::OffsetHost<'a> for SinglePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Single Adjustment Positioning Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#single-adjustment-positioning-format-2-array-of-positioning-values): Array of Positioning Values
pub struct SinglePosFormat2<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    value_records: DynSizedArray<'a, ValueFormat, ValueRecord>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SinglePosFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format = value_format.get();
        let (value_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_value_count = value_count.get();
        let (value_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(
                ..value_record_array_len(__resolved_value_format, __resolved_value_count) as usize,
            )?,
            &__resolved_value_format,
        )?;
        let _bytes = bytes;
        let result = SinglePosFormat2 {
            pos_format,
            coverage_offset,
            value_format,
            value_count,
            value_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SinglePosFormat2<'a> {
    /// Format identifier: format = 2
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of SinglePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Defines the types of data in the ValueRecords.
    pub fn value_format(&self) -> ValueFormat {
        self.value_format.get()
    }

    /// Number of ValueRecords — must equal glyphCount in the
    /// Coverage table.
    pub fn value_count(&self) -> u16 {
        self.value_count.get()
    }

    /// Array of ValueRecords — positioning values applied to glyphs.
    pub fn value_records(&self) -> &DynSizedArray<'a, ValueFormat, ValueRecord> {
        &self.value_records
    }
}

impl<'a> font_types::OffsetHost<'a> for SinglePosFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable): Single Adjustment Positioning Subtable
pub enum PairPos<'a> {
    Format1(PairPosFormat1<'a>),
    Format2(PairPosFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for PairPos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(PairPos)
                    );
                }
                None
            }
        }
    }
}

/// [Pair Adjustment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#pair-adjustment-positioning-format-1-adjustments-for-glyph-pairs): Adjustments for Glyph Pairs
pub struct PairPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format1: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_format2: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    pair_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    pair_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for PairPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format1, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let (value_format2, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let (pair_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_pair_set_count = pair_set_count.get();
        let (pair_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_pair_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = PairPosFormat1 {
            pos_format,
            coverage_offset,
            value_format1,
            value_format2,
            pair_set_count,
            pair_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> PairPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of PairPos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Defines the types of data in valueRecord1 — for the first
    /// glyph in the pair (may be zero).
    pub fn value_format1(&self) -> ValueFormat {
        self.value_format1.get()
    }

    /// Defines the types of data in valueRecord2 — for the second
    /// glyph in the pair (may be zero).
    pub fn value_format2(&self) -> ValueFormat {
        self.value_format2.get()
    }

    /// Number of PairSet tables
    pub fn pair_set_count(&self) -> u16 {
        self.pair_set_count.get()
    }

    /// Array of offsets to PairSet tables. Offsets are from beginning
    /// of PairPos subtable, ordered by Coverage Index.
    pub fn pair_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.pair_set_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for PairPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [PairPosFormat1]
pub struct PairSet<'a> {
    pair_value_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    pair_value_records: DynSizedArray<'a, (ValueFormat, ValueFormat), PairValueRecord>,
}

impl<'a> font_types::FontReadWithArgs<'a, (ValueFormat, ValueFormat)> for PairSet<'a> {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_value_format1 = args.0;
        let __resolved_value_format2 = args.1;
        let (pair_value_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_pair_value_count = pair_value_count.get();
        let (pair_value_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(
                ..pair_value_record_len(
                    __resolved_pair_value_count,
                    __resolved_value_format1,
                    __resolved_value_format2,
                ) as usize,
            )?,
            &(__resolved_value_format1, __resolved_value_format2),
        )?;
        let _bytes = bytes;
        let result = PairSet {
            pair_value_count,
            pair_value_records,
        };
        Some((result, _bytes))
    }
}

impl<'a> PairSet<'a> {
    /// Number of PairValueRecords
    pub fn pair_value_count(&self) -> u16 {
        self.pair_value_count.get()
    }

    /// Array of PairValueRecords, ordered by glyph ID of the second
    /// glyph.
    pub fn pair_value_records(
        &self,
    ) -> &DynSizedArray<'a, (ValueFormat, ValueFormat), PairValueRecord> {
        &self.pair_value_records
    }
}

/// [Pair Adjustment Positioning Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#pair-adjustment-positioning-format-2-class-pair-adjustment): Class Pair Adjustment
pub struct PairPosFormat2<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format1: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_format2: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    class_def1_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_def2_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class1_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class2_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class1_records: DynSizedArray<'a, (u16, ValueFormat, ValueFormat), Class1Record<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for PairPosFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format1, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format1 = value_format1.get();
        let (value_format2, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format2 = value_format2.get();
        let (class_def1_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_def2_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class1_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class1_count = class1_count.get();
        let (class2_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class2_count = class2_count.get();
        let (class1_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..__resolved_class1_count as usize)?,
            &(
                __resolved_class2_count,
                __resolved_value_format1,
                __resolved_value_format2,
            ),
        )?;
        let _bytes = bytes;
        let result = PairPosFormat2 {
            pos_format,
            coverage_offset,
            value_format1,
            value_format2,
            class_def1_offset,
            class_def2_offset,
            class1_count,
            class2_count,
            class1_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> PairPosFormat2<'a> {
    /// Format identifier: format = 2
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of PairPos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// ValueRecord definition — for the first glyph of the pair (may
    /// be zero).
    pub fn value_format1(&self) -> ValueFormat {
        self.value_format1.get()
    }

    /// ValueRecord definition — for the second glyph of the pair
    /// (may be zero).
    pub fn value_format2(&self) -> ValueFormat {
        self.value_format2.get()
    }

    /// Offset to ClassDef table, from beginning of PairPos subtable
    /// — for the first glyph of the pair.
    pub fn class_def1_offset(&self) -> Offset16 {
        self.class_def1_offset.get()
    }

    /// Offset to ClassDef table, from beginning of PairPos subtable
    /// — for the second glyph of the pair.
    pub fn class_def2_offset(&self) -> Offset16 {
        self.class_def2_offset.get()
    }

    /// Number of classes in classDef1 table — includes Class 0.
    pub fn class1_count(&self) -> u16 {
        self.class1_count.get()
    }

    /// Number of classes in classDef2 table — includes Class 0.
    pub fn class2_count(&self) -> u16 {
        self.class2_count.get()
    }

    /// Array of Class1 records, ordered by classes in classDef1.
    pub fn class1_records(
        &self,
    ) -> &DynSizedArray<'a, (u16, ValueFormat, ValueFormat), Class1Record<'a>> {
        &self.class1_records
    }
}

impl<'a> font_types::OffsetHost<'a> for PairPosFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [PairPosFormat2]
pub struct Class1Record<'a> {
    class2_records: DynSizedArray<'a, (ValueFormat, ValueFormat), Class2Record>,
}

impl<'a> font_types::FontReadWithArgs<'a, (u16, ValueFormat, ValueFormat)> for Class1Record<'a> {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(u16, ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_class2_count = args.0;
        let __resolved_value_format1 = args.1;
        let __resolved_value_format2 = args.2;
        let (class2_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..__resolved_class2_count as usize)?,
            &(__resolved_value_format1, __resolved_value_format2),
        )?;
        let _bytes = bytes;
        let result = Class1Record { class2_records };
        Some((result, _bytes))
    }
}

impl<'a> Class1Record<'a> {
    /// Array of Class2 records, ordered by classes in classDef2.
    pub fn class2_records(&self) -> &DynSizedArray<'a, (ValueFormat, ValueFormat), Class2Record> {
        &self.class2_records
    }
}

/// Part of [PairPosFormat2]
pub struct Class2Record {
    value_record1: ValueRecord,
    value_record2: ValueRecord,
}

impl<'a> font_types::FontReadWithArgs<'a, (ValueFormat, ValueFormat)> for Class2Record {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_value_format1 = args.0;
        let __resolved_value_format2 = args.1;
        let (value_record1, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..)?,
            &__resolved_value_format1,
        )?;
        let (value_record2, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..)?,
            &__resolved_value_format2,
        )?;
        let _bytes = bytes;
        let result = Class2Record {
            value_record1,
            value_record2,
        };
        Some((result, _bytes))
    }
}

impl Class2Record {
    /// Positioning for first glyph — empty if valueFormat1 = 0.
    pub fn value_record1(&self) -> &ValueRecord {
        &self.value_record1
    }

    /// Positioning for second glyph — empty if valueFormat2 = 0.
    pub fn value_record2(&self) -> &ValueRecord {
        &self.value_record2
    }
}

/// [Cursive Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#cursive-attachment-positioning-format1-cursive-attachment): Cursvie attachment
pub struct CursivePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    entry_exit_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    entry_exit_record: zerocopy::LayoutVerified<&'a [u8], [EntryExitRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for CursivePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (entry_exit_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_entry_exit_count = entry_exit_count.get();
        let (entry_exit_record, bytes) =
            zerocopy::LayoutVerified::<_, [EntryExitRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_entry_exit_count as usize,
            )?;
        let _bytes = bytes;
        let result = CursivePosFormat1 {
            pos_format,
            coverage_offset,
            entry_exit_count,
            entry_exit_record,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> CursivePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of CursivePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    /// Number of EntryExit records
    pub fn entry_exit_count(&self) -> u16 {
        self.entry_exit_count.get()
    }

    /// Array of EntryExit records, in Coverage index order.
    pub fn entry_exit_record(&self) -> &[EntryExitRecord] {
        &self.entry_exit_record
    }
}

impl<'a> font_types::OffsetHost<'a> for CursivePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [CursivePosFormat1]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct EntryExitRecord {
    /// Offset to entryAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub entry_anchor_offset: BigEndian<Offset16>,
    /// Offset to exitAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub exit_anchor_offset: BigEndian<Offset16>,
}

impl EntryExitRecord {
    /// Offset to entryAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub fn entry_anchor_offset(&self) -> Offset16 {
        self.entry_anchor_offset.get()
    }

    /// Offset to exitAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub fn exit_anchor_offset(&self) -> Offset16 {
        self.exit_anchor_offset.get()
    }
}

/// [Mark-to-Base Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-base-attachment-positioning-format-1-mark-to-base-attachment-point): Mark-to-base Attachment Point
pub struct MarkBasePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    base_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    base_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkBasePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (base_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (base_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkBasePosFormat1 {
            pos_format,
            mark_coverage_offset,
            base_coverage_offset,
            mark_class_count,
            mark_array_offset,
            base_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkBasePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to markCoverage table, from beginning of MarkBasePos
    /// subtable.
    pub fn mark_coverage_offset(&self) -> Offset16 {
        self.mark_coverage_offset.get()
    }

    /// Offset to baseCoverage table, from beginning of MarkBasePos
    /// subtable.
    pub fn base_coverage_offset(&self) -> Offset16 {
        self.base_coverage_offset.get()
    }

    /// Number of classes defined for marks
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table, from beginning of MarkBasePos
    /// subtable.
    pub fn mark_array_offset(&self) -> Offset16 {
        self.mark_array_offset.get()
    }

    /// Offset to BaseArray table, from beginning of MarkBasePos
    /// subtable.
    pub fn base_array_offset(&self) -> Offset16 {
        self.base_array_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkBasePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Mark-to-Ligature Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-ligature-attachment-positioning-format-1-mark-to-ligature-attachment): Mark-to-Ligature Attachment
pub struct MarkLigPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    ligature_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    ligature_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkLigPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (ligature_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (ligature_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkLigPosFormat1 {
            pos_format,
            mark_coverage_offset,
            ligature_coverage_offset,
            mark_class_count,
            mark_array_offset,
            ligature_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkLigPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to markCoverage table, from beginning of MarkLigPos
    /// subtable.
    pub fn mark_coverage_offset(&self) -> Offset16 {
        self.mark_coverage_offset.get()
    }

    /// Offset to ligatureCoverage table, from beginning of MarkLigPos
    /// subtable.
    pub fn ligature_coverage_offset(&self) -> Offset16 {
        self.ligature_coverage_offset.get()
    }

    /// Number of defined mark classes
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table, from beginning of MarkLigPos
    /// subtable.
    pub fn mark_array_offset(&self) -> Offset16 {
        self.mark_array_offset.get()
    }

    /// Offset to LigatureArray table, from beginning of MarkLigPos
    /// subtable.
    pub fn ligature_array_offset(&self) -> Offset16 {
        self.ligature_array_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkLigPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct LigatureArray<'a> {
    ligature_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    ligature_attach_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for LigatureArray<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (ligature_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_ligature_count = ligature_count.get();
        let (ligature_attach_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_ligature_count as usize,
            )?;
        let _bytes = bytes;
        let result = LigatureArray {
            ligature_count,
            ligature_attach_offsets,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> LigatureArray<'a> {
    /// Number of LigatureAttach table offsets
    pub fn ligature_count(&self) -> u16 {
        self.ligature_count.get()
    }

    /// Array of offsets to LigatureAttach tables. Offsets are from
    /// beginning of LigatureArray table, ordered by ligatureCoverage
    /// index.
    pub fn ligature_attach_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.ligature_attach_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LigatureArray<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct LigatureAttach<'a> {
    component_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    component_records: DynSizedArray<'a, u16, ComponentRecord<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for LigatureAttach<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (component_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_component_count = component_count.get();
        let (component_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(
                ..nested_offset_array_len(__resolved_component_count, __resolved_mark_class_count)
                    as usize,
            )?,
            &__resolved_mark_class_count,
        )?;
        let _bytes = bytes;
        let result = LigatureAttach {
            component_count,
            component_records,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> LigatureAttach<'a> {
    /// Number of ComponentRecords in this ligature
    pub fn component_count(&self) -> u16 {
        self.component_count.get()
    }

    /// Array of Component records, ordered in writing direction.
    pub fn component_records(&self) -> &DynSizedArray<'a, u16, ComponentRecord<'a>> {
        &self.component_records
    }
}

impl<'a> font_types::OffsetHost<'a> for LigatureAttach<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct ComponentRecord<'a> {
    ligature_anchor_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for ComponentRecord<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let (ligature_anchor_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_class_count as usize,
            )?;
        let _bytes = bytes;
        let result = ComponentRecord {
            ligature_anchor_offsets,
        };
        Some((result, _bytes))
    }
}

impl<'a> ComponentRecord<'a> {
    /// Array of offsets (one per class) to Anchor tables. Offsets are
    /// from beginning of LigatureAttach table, ordered by class
    /// (offsets may be NULL).
    pub fn ligature_anchor_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.ligature_anchor_offsets
    }
}

/// [Mark-to-Mark Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-mark-attachment-positioning-format-1-mark-to-mark-attachment): Mark-to-Mark Attachment
pub struct MarkMarkPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark1_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark2_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark1_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark2_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkMarkPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark1_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark2_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark1_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark2_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkMarkPosFormat1 {
            pos_format,
            mark1_coverage_offset,
            mark2_coverage_offset,
            mark_class_count,
            mark1_array_offset,
            mark2_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkMarkPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Combining Mark Coverage table, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark1_coverage_offset(&self) -> Offset16 {
        self.mark1_coverage_offset.get()
    }

    /// Offset to Base Mark Coverage table, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark2_coverage_offset(&self) -> Offset16 {
        self.mark2_coverage_offset.get()
    }

    /// Number of Combining Mark classes defined
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table for mark1, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark1_array_offset(&self) -> Offset16 {
        self.mark1_array_offset.get()
    }

    /// Offset to Mark2Array table for mark2, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark2_array_offset(&self) -> Offset16 {
        self.mark2_array_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkMarkPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkMarkPosFormat1]Class2Record
pub struct Mark2Array<'a> {
    mark2_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark2_records: DynSizedArray<'a, u16, Mark2Record<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for Mark2Array<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (mark2_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_mark2_count = mark2_count.get();
        let (mark2_records, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(
                ..nested_offset_array_len(__resolved_mark2_count, __resolved_mark_class_count)
                    as usize,
            )?,
            &__resolved_mark_class_count,
        )?;
        let _bytes = bytes;
        let result = Mark2Array {
            mark2_count,
            mark2_records,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> Mark2Array<'a> {
    /// Number of Mark2 records
    pub fn mark2_count(&self) -> u16 {
        self.mark2_count.get()
    }

    /// Array of Mark2Records, in Coverage order.
    pub fn mark2_records(&self) -> &DynSizedArray<'a, u16, Mark2Record<'a>> {
        &self.mark2_records
    }
}

impl<'a> font_types::OffsetHost<'a> for Mark2Array<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkMarkPosFormat1]
pub struct Mark2Record<'a> {
    mark2_anchor_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for Mark2Record<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let (mark2_anchor_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_class_count as usize,
            )?;
        let _bytes = bytes;
        let result = Mark2Record {
            mark2_anchor_offsets,
        };
        Some((result, _bytes))
    }
}

impl<'a> Mark2Record<'a> {
    /// Array of offsets (one per class) to Anchor tables. Offsets are
    /// from beginning of Mark2Array table, in class order (offsets may
    /// be NULL).
    pub fn mark2_anchor_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.mark2_anchor_offsets
    }
}

/// [Extension Positioning Subtable Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#extension-positioning-subtable-format-1)
pub struct ExtensionPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    extension_lookup_type: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    extension_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset32>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ExtensionPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (extension_lookup_type, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (extension_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset32>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = ExtensionPosFormat1 {
            pos_format,
            extension_lookup_type,
            extension_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ExtensionPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Lookup type of subtable referenced by extensionOffset (i.e. the
    /// extension subtable).
    pub fn extension_lookup_type(&self) -> u16 {
        self.extension_lookup_type.get()
    }

    /// Offset to the extension subtable, of lookup type
    /// extensionLookupType, relative to the start of the
    /// ExtensionPosFormat1 subtable.
    pub fn extension_offset(&self) -> Offset32 {
        self.extension_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for ExtensionPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

fn value_record_array_len(format: ValueFormat, count: u16) -> usize {
    count as usize * value_record_len(format)
}

fn value_record_len(format: ValueFormat) -> usize {
    format.bits().count_ones() as usize * std::mem::size_of::<u16>()
}

fn pair_value_record_len(count: u16, format1: ValueFormat, format2: ValueFormat) -> usize {
    std::mem::size_of::<u16>()
        + format1.record_byte_len()
        + format2.record_byte_len() * count as usize
}

fn nested_offset_array_len(array_len: u16, mark_class_count: u16) -> usize {
    std::mem::size_of::<u16>() * mark_class_count as usize * array_len as usize
}

#[cfg(feature = "compile")]
pub mod compile {
    use super::ValueFormat;
    use crate::compile::*;
    use crate::layout::compile::ClassDef;
    use crate::layout::compile::CoverageTable;
    use crate::layout::compile::FeatureList;
    use crate::layout::compile::FeatureVariations;
    use crate::layout::compile::ScriptList;
    use crate::tables::gpos::compile::BaseArray;
    use crate::tables::gpos::compile::PairValueRecord;
    use crate::tables::gpos::compile::PositionLookupList;
    use crate::tables::gpos::compile::ValueRecord;
    use font_types::*;

    #[derive(Debug, PartialEq)]
    pub struct Gpos1_0 {
        pub major_version: u16,
        pub minor_version: u16,
        pub script_list_offset: OffsetMarker<Offset16, ScriptList>,
        pub feature_list_offset: OffsetMarker<Offset16, FeatureList>,
        pub lookup_list_offset: OffsetMarker<Offset16, PositionLookupList>,
    }

    impl ToOwnedObj for super::Gpos1_0<'_> {
        type Owned = Gpos1_0;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Gpos1_0 {
                major_version: self.major_version(),
                minor_version: self.minor_version(),
                script_list_offset: OffsetMarker::new_maybe_null(
                    self.script_list_offset()
                        .read::<super::ScriptList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                feature_list_offset: OffsetMarker::new_maybe_null(
                    self.feature_list_offset()
                        .read::<super::FeatureList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lookup_list_offset: OffsetMarker::new_maybe_null(
                    self.lookup_list_offset()
                        .read::<super::PositionLookupList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::Gpos1_0<'_> {}

    impl FontWrite for Gpos1_0 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.major_version.write_into(writer);
            self.minor_version.write_into(writer);
            self.script_list_offset.write_into(writer);
            self.feature_list_offset.write_into(writer);
            self.lookup_list_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Gpos1_1 {
        pub major_version: u16,
        pub minor_version: u16,
        pub script_list_offset: OffsetMarker<Offset16, ScriptList>,
        pub feature_list_offset: OffsetMarker<Offset16, FeatureList>,
        pub lookup_list_offset: OffsetMarker<Offset16, PositionLookupList>,
        pub feature_variations_offset: OffsetMarker<Offset32, FeatureVariations>,
    }

    impl ToOwnedObj for super::Gpos1_1<'_> {
        type Owned = Gpos1_1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Gpos1_1 {
                major_version: self.major_version(),
                minor_version: self.minor_version(),
                script_list_offset: OffsetMarker::new_maybe_null(
                    self.script_list_offset()
                        .read::<super::ScriptList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                feature_list_offset: OffsetMarker::new_maybe_null(
                    self.feature_list_offset()
                        .read::<super::FeatureList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                lookup_list_offset: OffsetMarker::new_maybe_null(
                    self.lookup_list_offset()
                        .read::<super::PositionLookupList>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                feature_variations_offset: OffsetMarker::new_maybe_null(
                    self.feature_variations_offset()
                        .read::<super::FeatureVariations>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::Gpos1_1<'_> {}

    impl FontWrite for Gpos1_1 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.major_version.write_into(writer);
            self.minor_version.write_into(writer);
            self.script_list_offset.write_into(writer);
            self.feature_list_offset.write_into(writer);
            self.lookup_list_offset.write_into(writer);
            self.feature_variations_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum Gpos {
        Version1_0(Gpos1_0),
        Version1_1(Gpos1_1),
    }

    impl ToOwnedObj for super::Gpos<'_> {
        type Owned = Gpos;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::Gpos::Version1_0(item) => Gpos::Version1_0(item.to_owned_obj(offset_data)?),
                super::Gpos::Version1_1(item) => Gpos::Version1_1(item.to_owned_obj(offset_data)?),
            })
        }
    }

    impl FontWrite for Gpos {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Version1_0(item) => item.write_into(writer),
                Self::Version1_1(item) => item.write_into(writer),
            }
        }
    }

    impl FontWrite for ValueFormat {
        fn write_into(&self, writer: &mut TableWriter) {
            self.bits().write_into(writer)
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum AnchorTable {
        Format1(AnchorFormat1),
        Format2(AnchorFormat2),
        Format3(AnchorFormat3),
    }

    impl ToOwnedObj for super::AnchorTable<'_> {
        type Owned = AnchorTable;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::AnchorTable::Format1(item) => {
                    AnchorTable::Format1(item.to_owned_obj(offset_data)?)
                }
                super::AnchorTable::Format2(item) => {
                    AnchorTable::Format2(item.to_owned_obj(offset_data)?)
                }
                super::AnchorTable::Format3(item) => {
                    AnchorTable::Format3(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl FontWrite for AnchorTable {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
                Self::Format3(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct AnchorFormat1 {
        pub anchor_format: u16,
        pub x_coordinate: i16,
        pub y_coordinate: i16,
    }

    impl ToOwnedObj for super::AnchorFormat1 {
        type Owned = AnchorFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(AnchorFormat1 {
                anchor_format: self.anchor_format(),
                x_coordinate: self.x_coordinate(),
                y_coordinate: self.y_coordinate(),
            })
        }
    }

    impl FontWrite for AnchorFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.anchor_format.write_into(writer);
            self.x_coordinate.write_into(writer);
            self.y_coordinate.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct AnchorFormat2 {
        pub anchor_format: u16,
        pub x_coordinate: i16,
        pub y_coordinate: i16,
        pub anchor_point: u16,
    }

    impl ToOwnedObj for super::AnchorFormat2 {
        type Owned = AnchorFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(AnchorFormat2 {
                anchor_format: self.anchor_format(),
                x_coordinate: self.x_coordinate(),
                y_coordinate: self.y_coordinate(),
                anchor_point: self.anchor_point(),
            })
        }
    }

    impl FontWrite for AnchorFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.anchor_format.write_into(writer);
            self.x_coordinate.write_into(writer);
            self.y_coordinate.write_into(writer);
            self.anchor_point.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct FakeDeviceTable {
        pub version: u16,
    }

    impl ToOwnedObj for super::FakeDeviceTable {
        type Owned = FakeDeviceTable;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(FakeDeviceTable {
                version: self.version(),
            })
        }
    }

    impl FontWrite for FakeDeviceTable {
        fn write_into(&self, writer: &mut TableWriter) {
            self.version.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct AnchorFormat3 {
        pub anchor_format: u16,
        pub x_coordinate: i16,
        pub y_coordinate: i16,
        pub x_device_offset: OffsetMarker<Offset16, FakeDeviceTable>,
        pub y_device_offset: OffsetMarker<Offset16, FakeDeviceTable>,
    }

    impl ToOwnedObj for super::AnchorFormat3<'_> {
        type Owned = AnchorFormat3;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(AnchorFormat3 {
                anchor_format: self.anchor_format(),
                x_coordinate: self.x_coordinate(),
                y_coordinate: self.y_coordinate(),
                x_device_offset: OffsetMarker::new_maybe_null(
                    self.x_device_offset()
                        .read::<super::FakeDeviceTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                y_device_offset: OffsetMarker::new_maybe_null(
                    self.y_device_offset()
                        .read::<super::FakeDeviceTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl ToOwnedTable for super::AnchorFormat3<'_> {}

    impl FontWrite for AnchorFormat3 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.anchor_format.write_into(writer);
            self.x_coordinate.write_into(writer);
            self.y_coordinate.write_into(writer);
            self.x_device_offset.write_into(writer);
            self.y_device_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct MarkArray {
        pub mark_count: u16,
        pub mark_records: Vec<MarkRecord>,
    }

    impl ToOwnedObj for super::MarkArray<'_> {
        type Owned = MarkArray;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(MarkArray {
                mark_count: self.mark_count(),
                mark_records: self
                    .mark_records()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for MarkArray {
        fn write_into(&self, writer: &mut TableWriter) {
            self.mark_count.write_into(writer);
            self.mark_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct MarkRecord {
        pub mark_class: u16,
        pub mark_anchor_offset: OffsetMarker<Offset16, AnchorTable>,
    }

    impl ToOwnedObj for super::MarkRecord {
        type Owned = MarkRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(MarkRecord {
                mark_class: self.mark_class(),
                mark_anchor_offset: OffsetMarker::new_maybe_null(
                    self.mark_anchor_offset()
                        .read::<super::AnchorTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for MarkRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.mark_class.write_into(writer);
            self.mark_anchor_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum SinglePos {
        Format1(SinglePosFormat1),
        Format2(SinglePosFormat2),
    }

    impl ToOwnedObj for super::SinglePos<'_> {
        type Owned = SinglePos;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::SinglePos::Format1(item) => {
                    SinglePos::Format1(item.to_owned_obj(offset_data)?)
                }
                super::SinglePos::Format2(item) => {
                    SinglePos::Format2(item.to_owned_obj(offset_data)?)
                }
            })
        }
    }

    impl ToOwnedTable for super::SinglePos<'_> {}

    impl FontWrite for SinglePos {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SinglePosFormat1 {
        pub pos_format: u16,
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub value_format: ValueFormat,
        pub value_record: ValueRecord,
    }

    impl ToOwnedObj for super::SinglePosFormat1<'_> {
        type Owned = SinglePosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SinglePosFormat1 {
                pos_format: self.pos_format(),
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                value_format: self.value_format(),
                value_record: self.value_record.to_owned_obj(offset_data)?,
            })
        }
    }

    impl ToOwnedTable for super::SinglePosFormat1<'_> {}

    impl FontWrite for SinglePosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.pos_format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.value_format.write_into(writer);
            self.value_record.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct SinglePosFormat2 {
        pub pos_format: u16,
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub value_format: ValueFormat,
        pub value_count: u16,
        pub value_records: Vec<ValueRecord>,
    }

    impl ToOwnedObj for super::SinglePosFormat2<'_> {
        type Owned = SinglePosFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(SinglePosFormat2 {
                pos_format: self.pos_format(),
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                value_format: self.value_format(),
                value_count: self.value_count(),
                value_records: self.value_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl ToOwnedTable for super::SinglePosFormat2<'_> {}

    impl FontWrite for SinglePosFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            self.pos_format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.value_format.write_into(writer);
            self.value_count.write_into(writer);
            self.value_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub enum PairPos {
        Format1(PairPosFormat1),
        Format2(PairPosFormat2),
    }

    impl ToOwnedObj for super::PairPos<'_> {
        type Owned = PairPos;
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(match self {
                super::PairPos::Format1(item) => PairPos::Format1(item.to_owned_obj(offset_data)?),
                super::PairPos::Format2(item) => PairPos::Format2(item.to_owned_obj(offset_data)?),
            })
        }
    }

    impl ToOwnedTable for super::PairPos<'_> {}

    impl FontWrite for PairPos {
        fn write_into(&self, writer: &mut TableWriter) {
            match self {
                Self::Format1(item) => item.write_into(writer),
                Self::Format2(item) => item.write_into(writer),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct PairPosFormat1 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub value_format1: ValueFormat,
        pub value_format2: ValueFormat,
        pub pair_set_offsets: Vec<OffsetMarker<Offset16, PairSet>>,
    }

    impl ToOwnedObj for super::PairPosFormat1<'_> {
        type Owned = PairPosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(PairPosFormat1 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                value_format1: self.value_format1(),
                value_format2: self.value_format2(),
                pair_set_offsets: self.pair_sets_to_owned()?,
            })
        }
    }

    impl ToOwnedTable for super::PairPosFormat1<'_> {}

    impl FontWrite for PairPosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 1;
            pos_format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.value_format1.write_into(writer);
            self.value_format2.write_into(writer);
            u16::try_from(self.pair_set_offsets.len())
                .unwrap()
                .write_into(writer);
            self.pair_set_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct PairSet {
        pub pair_value_count: u16,
        pub pair_value_records: Vec<PairValueRecord>,
    }

    impl ToOwnedObj for super::PairSet<'_> {
        type Owned = PairSet;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(PairSet {
                pair_value_count: self.pair_value_count(),
                pair_value_records: self.pair_value_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl FontWrite for PairSet {
        fn write_into(&self, writer: &mut TableWriter) {
            self.pair_value_count.write_into(writer);
            self.pair_value_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct PairPosFormat2 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub value_format1: ValueFormat,
        pub value_format2: ValueFormat,
        pub class_def1_offset: OffsetMarker<Offset16, ClassDef>,
        pub class_def2_offset: OffsetMarker<Offset16, ClassDef>,
        pub class1_count: u16,
        pub class2_count: u16,
        pub class1_records: Vec<Class1Record>,
    }

    impl ToOwnedObj for super::PairPosFormat2<'_> {
        type Owned = PairPosFormat2;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(PairPosFormat2 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                value_format1: self.value_format1(),
                value_format2: self.value_format2(),
                class_def1_offset: OffsetMarker::new_maybe_null(
                    self.class_def1_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                class_def2_offset: OffsetMarker::new_maybe_null(
                    self.class_def2_offset()
                        .read::<super::ClassDef>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                class1_count: self.class1_count(),
                class2_count: self.class2_count(),
                class1_records: self.class1_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl ToOwnedTable for super::PairPosFormat2<'_> {}

    impl FontWrite for PairPosFormat2 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 2;
            pos_format.write_into(writer);
            self.coverage_offset.write_into(writer);
            self.value_format1.write_into(writer);
            self.value_format2.write_into(writer);
            self.class_def1_offset.write_into(writer);
            self.class_def2_offset.write_into(writer);
            self.class1_count.write_into(writer);
            self.class2_count.write_into(writer);
            self.class1_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Class1Record {
        pub class2_records: Vec<Class2Record>,
    }

    impl ToOwnedObj for super::Class1Record<'_> {
        type Owned = Class1Record;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(Class1Record {
                class2_records: self.class2_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl FontWrite for Class1Record {
        fn write_into(&self, writer: &mut TableWriter) {
            self.class2_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Class2Record {
        pub value_record1: ValueRecord,
        pub value_record2: ValueRecord,
    }

    impl ToOwnedObj for super::Class2Record {
        type Owned = Class2Record;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(Class2Record {
                value_record1: self.value_record1.to_owned_obj(offset_data)?,
                value_record2: self.value_record2.to_owned_obj(offset_data)?,
            })
        }
    }

    impl FontWrite for Class2Record {
        fn write_into(&self, writer: &mut TableWriter) {
            self.value_record1.write_into(writer);
            self.value_record2.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct CursivePosFormat1 {
        pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub entry_exit_record: Vec<EntryExitRecord>,
    }

    impl ToOwnedObj for super::CursivePosFormat1<'_> {
        type Owned = CursivePosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(CursivePosFormat1 {
                coverage_offset: OffsetMarker::new_maybe_null(
                    self.coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                entry_exit_record: self
                    .entry_exit_record()
                    .iter()
                    .map(|item| item.to_owned_obj(offset_data))
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl ToOwnedTable for super::CursivePosFormat1<'_> {}

    impl FontWrite for CursivePosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 1;
            pos_format.write_into(writer);
            self.coverage_offset.write_into(writer);
            u16::try_from(self.entry_exit_record.len())
                .unwrap()
                .write_into(writer);
            self.entry_exit_record.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct EntryExitRecord {
        pub entry_anchor_offset: OffsetMarker<Offset16, AnchorTable>,
        pub exit_anchor_offset: OffsetMarker<Offset16, AnchorTable>,
    }

    impl ToOwnedObj for super::EntryExitRecord {
        type Owned = EntryExitRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(EntryExitRecord {
                entry_anchor_offset: OffsetMarker::new_maybe_null(
                    self.entry_anchor_offset()
                        .read::<super::AnchorTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                exit_anchor_offset: OffsetMarker::new_maybe_null(
                    self.exit_anchor_offset()
                        .read::<super::AnchorTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
            })
        }
    }

    impl FontWrite for EntryExitRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.entry_anchor_offset.write_into(writer);
            self.exit_anchor_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct MarkBasePosFormat1 {
        pub mark_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub base_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub mark_class_count: u16,
        pub mark_array_offset: OffsetMarker<Offset16, MarkArray>,
        pub base_array_offset: OffsetMarker<Offset16, BaseArray>,
    }

    impl ToOwnedObj for super::MarkBasePosFormat1<'_> {
        type Owned = MarkBasePosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(MarkBasePosFormat1 {
                mark_coverage_offset: OffsetMarker::new_maybe_null(
                    self.mark_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                base_coverage_offset: OffsetMarker::new_maybe_null(
                    self.base_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_class_count: self.mark_class_count(),
                mark_array_offset: OffsetMarker::new_maybe_null(
                    self.mark_array_offset()
                        .read::<super::MarkArray>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                base_array_offset: self.base_array_to_owned()?,
            })
        }
    }

    impl ToOwnedTable for super::MarkBasePosFormat1<'_> {}

    impl FontWrite for MarkBasePosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 1;
            pos_format.write_into(writer);
            self.mark_coverage_offset.write_into(writer);
            self.base_coverage_offset.write_into(writer);
            self.mark_class_count.write_into(writer);
            self.mark_array_offset.write_into(writer);
            self.base_array_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct MarkLigPosFormat1 {
        pub mark_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub ligature_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub mark_class_count: u16,
        pub mark_array_offset: OffsetMarker<Offset16, MarkArray>,
        pub ligature_array_offset: OffsetMarker<Offset16, LigatureArray>,
    }

    impl ToOwnedObj for super::MarkLigPosFormat1<'_> {
        type Owned = MarkLigPosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(MarkLigPosFormat1 {
                mark_coverage_offset: OffsetMarker::new_maybe_null(
                    self.mark_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                ligature_coverage_offset: OffsetMarker::new_maybe_null(
                    self.ligature_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_class_count: self.mark_class_count(),
                mark_array_offset: OffsetMarker::new_maybe_null(
                    self.mark_array_offset()
                        .read::<super::MarkArray>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                ligature_array_offset: self.ligature_array_to_owned()?,
            })
        }
    }

    impl ToOwnedTable for super::MarkLigPosFormat1<'_> {}

    impl FontWrite for MarkLigPosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 1;
            pos_format.write_into(writer);
            self.mark_coverage_offset.write_into(writer);
            self.ligature_coverage_offset.write_into(writer);
            self.mark_class_count.write_into(writer);
            self.mark_array_offset.write_into(writer);
            self.ligature_array_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct LigatureArray {
        pub ligature_attach_offsets: Vec<OffsetMarker<Offset16, LigatureAttach>>,
    }

    impl FontWrite for LigatureArray {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.ligature_attach_offsets.len())
                .unwrap()
                .write_into(writer);
            self.ligature_attach_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct LigatureAttach {
        pub component_records: Vec<ComponentRecord>,
    }

    impl ToOwnedObj for super::LigatureAttach<'_> {
        type Owned = LigatureAttach;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(LigatureAttach {
                component_records: self.component_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl ToOwnedTable for super::LigatureAttach<'_> {}

    impl FontWrite for LigatureAttach {
        fn write_into(&self, writer: &mut TableWriter) {
            u16::try_from(self.component_records.len())
                .unwrap()
                .write_into(writer);
            self.component_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct ComponentRecord {
        pub ligature_anchor_offsets: Vec<OffsetMarker<Offset16, AnchorTable>>,
    }

    impl ToOwnedObj for super::ComponentRecord<'_> {
        type Owned = ComponentRecord;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(ComponentRecord {
                ligature_anchor_offsets: self
                    .ligature_anchor_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::AnchorTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for ComponentRecord {
        fn write_into(&self, writer: &mut TableWriter) {
            self.ligature_anchor_offsets.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct MarkMarkPosFormat1 {
        pub mark1_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub mark2_coverage_offset: OffsetMarker<Offset16, CoverageTable>,
        pub mark_class_count: u16,
        pub mark1_array_offset: OffsetMarker<Offset16, MarkArray>,
        pub mark2_array_offset: OffsetMarker<Offset16, Mark2Array>,
    }

    impl ToOwnedObj for super::MarkMarkPosFormat1<'_> {
        type Owned = MarkMarkPosFormat1;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(MarkMarkPosFormat1 {
                mark1_coverage_offset: OffsetMarker::new_maybe_null(
                    self.mark1_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark2_coverage_offset: OffsetMarker::new_maybe_null(
                    self.mark2_coverage_offset()
                        .read::<super::CoverageTable>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark_class_count: self.mark_class_count(),
                mark1_array_offset: OffsetMarker::new_maybe_null(
                    self.mark1_array_offset()
                        .read::<super::MarkArray>(offset_data)
                        .and_then(|obj| obj.to_owned_obj(offset_data)),
                ),
                mark2_array_offset: self.mark2_array_to_owned()?,
            })
        }
    }

    impl ToOwnedTable for super::MarkMarkPosFormat1<'_> {}

    impl FontWrite for MarkMarkPosFormat1 {
        fn write_into(&self, writer: &mut TableWriter) {
            let pos_format: u16 = 1;
            pos_format.write_into(writer);
            self.mark1_coverage_offset.write_into(writer);
            self.mark2_coverage_offset.write_into(writer);
            self.mark_class_count.write_into(writer);
            self.mark1_array_offset.write_into(writer);
            self.mark2_array_offset.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Mark2Array {
        pub mark2_count: u16,
        pub mark2_records: Vec<Mark2Record>,
    }

    impl ToOwnedObj for super::Mark2Array<'_> {
        type Owned = Mark2Array;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            let offset_data = self.bytes();
            Some(Mark2Array {
                mark2_count: self.mark2_count(),
                mark2_records: self.mark2_records.to_owned_obj(offset_data)?,
            })
        }
    }

    impl ToOwnedTable for super::Mark2Array<'_> {}

    impl FontWrite for Mark2Array {
        fn write_into(&self, writer: &mut TableWriter) {
            self.mark2_count.write_into(writer);
            self.mark2_records.write_into(writer);
        }
    }

    #[derive(Debug, PartialEq)]
    pub struct Mark2Record {
        pub mark2_anchor_offsets: Vec<OffsetMarker<Offset16, AnchorTable>>,
    }

    impl ToOwnedObj for super::Mark2Record<'_> {
        type Owned = Mark2Record;

        #[allow(unused_variables)]
        fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
            Some(Mark2Record {
                mark2_anchor_offsets: self
                    .mark2_anchor_offsets()
                    .iter()
                    .map(|item| {
                        Some(OffsetMarker::new_maybe_null(
                            item.get()
                                .read::<super::AnchorTable>(offset_data)
                                .and_then(|obj| obj.to_owned_obj(offset_data)),
                        ))
                    })
                    .collect::<Option<Vec<_>>>()?,
            })
        }
    }

    impl FontWrite for Mark2Record {
        fn write_into(&self, writer: &mut TableWriter) {
            self.mark2_anchor_offsets.write_into(writer);
        }
    }
}

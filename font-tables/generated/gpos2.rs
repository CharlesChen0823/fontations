// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::parse_prelude::*;

#[derive(Debug, Clone, Copy)]
pub struct Gpos;

#[derive(Debug, Clone, Copy)]
pub struct GposShape {}

impl GposShape {
    fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + MajorMinor::RAW_BYTE_LEN
    }
    fn script_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn feature_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.script_list_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn lookup_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.feature_list_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn feature_variations_offset_byte_range(&self) -> Range<usize> {
        let start = self.lookup_list_offset_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat1;

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat1Shape {}

impl AnchorFormat1Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat2;

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat2Shape {}

impl AnchorFormat2Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn anchor_point_byte_range(&self) -> Range<usize> {
        let start = self.y_coordinate_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat3;

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat3Shape {}

impl AnchorFormat3Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn x_device_offset_byte_range(&self) -> Range<usize> {
        let start = self.y_coordinate_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn y_device_offset_byte_range(&self) -> Range<usize> {
        let start = self.x_device_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
}

#[derive(Debug, Clone, Copy)]
pub struct MarkArray;

#[derive(Debug, Clone, Copy)]
pub struct MarkArrayShape {
    mark_records_byte_len: usize,
}

impl MarkArrayShape {
    fn mark_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn mark_records_byte_range(&self) -> Range<usize> {
        let start = self.mark_count_byte_range().end;
        start..start + self.mark_records_byte_len
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
#[repr(packed)]
pub struct MarkRecord {
    /// Class defined for the associated mark.
    pub mark_class: BigEndian<u16>,
    /// Offset to Anchor table, from beginning of MarkArray table.
    pub mark_anchor_offset: BigEndian<Offset16>,
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat1;

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat1Shape {
    value_record_byte_len: usize,
}

impl SinglePosFormat1Shape {
    fn pos_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.pos_format_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn value_format_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + ValueFormat::RAW_BYTE_LEN
    }
    fn value_record_byte_range(&self) -> Range<usize> {
        let start = self.value_format_byte_range().end;
        start..start + self.value_record_byte_len
    }
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat2;

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat2Shape {
    value_records_byte_len: usize,
}

impl SinglePosFormat2Shape {
    fn pos_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.pos_format_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn value_format_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + ValueFormat::RAW_BYTE_LEN
    }
    fn value_count_byte_range(&self) -> Range<usize> {
        let start = self.value_format_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn value_records_byte_range(&self) -> Range<usize> {
        let start = self.value_count_byte_range().end;
        start..start + self.value_records_byte_len
    }
}

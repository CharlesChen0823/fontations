// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::parse_prelude::*;

#[derive(Debug, Clone, Copy)]
pub struct Gpos;

#[derive(Debug, Clone, Copy)]
pub struct GposShape {
    feature_variations_offset_byte_start: Option<usize>,
}

impl GposShape {
    fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + MajorMinor::RAW_BYTE_LEN
    }
    fn script_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn feature_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.script_list_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn lookup_list_offset_byte_range(&self) -> Range<usize> {
        let start = self.feature_list_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn feature_variations_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.feature_variations_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }
}

impl TableInfo for Gpos {
    type Info = GposShape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        let version: MajorMinor = cursor.read()?;
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        let feature_variations_offset_byte_start = version
            .compatible(MajorMinor::VERSION_1_1)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(MajorMinor::VERSION_1_1)
            .then(|| cursor.advance::<Offset32>());
        cursor.finish(GposShape {
            feature_variations_offset_byte_start,
        })
    }
}

impl<'a> TableRef<'a, Gpos> {
    pub fn version(&self) -> MajorMinor {
        let range = self.shape.version_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn script_list_offset(&self) -> Offset16 {
        let range = self.shape.script_list_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn feature_list_offset(&self) -> Offset16 {
        let range = self.shape.feature_list_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn lookup_list_offset(&self) -> Offset16 {
        let range = self.shape.lookup_list_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn feature_variations_offset(&self) -> Option<Offset32> {
        let range = self.shape.feature_variations_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }
}

bitflags::bitflags! { # [doc = " See [ValueRecord]"] pub struct ValueFormat : u16 { # [doc = " Includes horizontal adjustment for placement"] const X_PLACEMENT = 0x0001 ; # [doc = " Includes vertical adjustment for placement"] const Y_PLACEMENT = 0x0002 ; # [doc = " Includes horizontal adjustment for advance"] const X_ADVANCE = 0x0004 ; # [doc = " Includes vertical adjustment for advance"] const Y_ADVANCE = 0x0008 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal placement"] const X_PLACEMENT_DEVICE = 0x0010 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical placement"] const Y_PLACEMENT_DEVICE = 0x0020 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal advance"] const X_ADVANCE_DEVICE = 0x0040 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical advance"] const Y_ADVANCE_DEVICE = 0x0080 ; } }

impl font_types::Scalar for ValueFormat {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        self.bits().to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::from_bits_truncate(t)
    }
}

impl FixedSized for ValueFormat {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN;
}

impl ReadScalar for ValueFormat {
    fn read(bytes: &[u8]) -> Option<Self> {
        u16::read(bytes).map(Self::from_bits_truncate)
    }
}

pub enum AnchorTable<'a> {
    Format1(TableRef<'a, AnchorFormat1>),
    Format2(TableRef<'a, AnchorFormat2>),
    Format3(TableRef<'a, AnchorFormat3>),
}

impl<'a> FontRead<'a> for AnchorTable<'a> {
    fn read(data: &FontData<'a>) -> Result<Self, ReadError> {
        let format: u16 = data.read_at(0)?;
        match format {
            <AnchorFormat1 as Format<u16>>::FORMAT => Ok(Self::Format1(FontRead::read(data)?)),
            <AnchorFormat2 as Format<u16>>::FORMAT => Ok(Self::Format2(FontRead::read(data)?)),
            <AnchorFormat3 as Format<u16>>::FORMAT => Ok(Self::Format3(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other)),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat1;

impl Format<u16> for AnchorFormat1 {
    const FORMAT: u16 = 1;
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat1Shape {}

impl AnchorFormat1Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
}

impl TableInfo for AnchorFormat1 {
    type Info = AnchorFormat1Shape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<i16>();
        cursor.advance::<i16>();
        cursor.finish(AnchorFormat1Shape {})
    }
}

impl<'a> TableRef<'a, AnchorFormat1> {
    pub fn anchor_format(&self) -> u16 {
        let range = self.shape.anchor_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn x_coordinate(&self) -> i16 {
        let range = self.shape.x_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn y_coordinate(&self) -> i16 {
        let range = self.shape.y_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat2;

impl Format<u16> for AnchorFormat2 {
    const FORMAT: u16 = 2;
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat2Shape {}

impl AnchorFormat2Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn anchor_point_byte_range(&self) -> Range<usize> {
        let start = self.y_coordinate_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
}

impl TableInfo for AnchorFormat2 {
    type Info = AnchorFormat2Shape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<i16>();
        cursor.advance::<i16>();
        cursor.advance::<u16>();
        cursor.finish(AnchorFormat2Shape {})
    }
}

impl<'a> TableRef<'a, AnchorFormat2> {
    pub fn anchor_format(&self) -> u16 {
        let range = self.shape.anchor_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn x_coordinate(&self) -> i16 {
        let range = self.shape.x_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn y_coordinate(&self) -> i16 {
        let range = self.shape.y_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn anchor_point(&self) -> u16 {
        let range = self.shape.anchor_point_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat3;

impl Format<u16> for AnchorFormat3 {
    const FORMAT: u16 = 3;
}

#[derive(Debug, Clone, Copy)]
pub struct AnchorFormat3Shape {}

impl AnchorFormat3Shape {
    fn anchor_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn x_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.anchor_format_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn y_coordinate_byte_range(&self) -> Range<usize> {
        let start = self.x_coordinate_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
    fn x_device_offset_byte_range(&self) -> Range<usize> {
        let start = self.y_coordinate_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn y_device_offset_byte_range(&self) -> Range<usize> {
        let start = self.x_device_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
}

impl TableInfo for AnchorFormat3 {
    type Info = AnchorFormat3Shape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<i16>();
        cursor.advance::<i16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.finish(AnchorFormat3Shape {})
    }
}

impl<'a> TableRef<'a, AnchorFormat3> {
    pub fn anchor_format(&self) -> u16 {
        let range = self.shape.anchor_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn x_coordinate(&self) -> i16 {
        let range = self.shape.x_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn y_coordinate(&self) -> i16 {
        let range = self.shape.y_coordinate_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn x_device_offset(&self) -> Offset16 {
        let range = self.shape.x_device_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn y_device_offset(&self) -> Offset16 {
        let range = self.shape.y_device_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[derive(Debug, Clone, Copy)]
pub struct MarkArray;

#[derive(Debug, Clone, Copy)]
pub struct MarkArrayShape {
    mark_records_byte_len: usize,
}

impl MarkArrayShape {
    fn mark_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn mark_records_byte_range(&self) -> Range<usize> {
        let start = self.mark_count_byte_range().end;
        start..start + self.mark_records_byte_len
    }
}

impl TableInfo for MarkArray {
    type Info = MarkArrayShape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        let mark_count: u16 = cursor.read()?;
        let mark_records_byte_len = (mark_count) as usize * MarkRecord::RAW_BYTE_LEN;
        cursor.advance_by(mark_records_byte_len);
        cursor.finish(MarkArrayShape {
            mark_records_byte_len,
        })
    }
}

impl<'a> TableRef<'a, MarkArray> {
    pub fn mark_count(&self) -> u16 {
        let range = self.shape.mark_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn mark_records(&self) -> &[MarkRecord] {
        let range = self.shape.mark_records_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
#[repr(packed)]
pub struct MarkRecord {
    /// Class defined for the associated mark.
    pub mark_class: BigEndian<u16>,
    /// Offset to Anchor table, from beginning of MarkArray table.
    pub mark_anchor_offset: BigEndian<Offset16>,
}

impl FixedSized for MarkRecord {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + Offset16::RAW_BYTE_LEN;
}

/// [Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable): Single Adjustment Positioning Subtable
pub enum SinglePos<'a> {
    Format1(TableRef<'a, SinglePosFormat1>),
    Format2(TableRef<'a, SinglePosFormat2>),
}

impl<'a> FontRead<'a> for SinglePos<'a> {
    fn read(data: &FontData<'a>) -> Result<Self, ReadError> {
        let format: u16 = data.read_at(0)?;
        match format {
            <SinglePosFormat1 as Format<u16>>::FORMAT => Ok(Self::Format1(FontRead::read(data)?)),
            <SinglePosFormat2 as Format<u16>>::FORMAT => Ok(Self::Format2(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other)),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat1;

impl Format<u16> for SinglePosFormat1 {
    const FORMAT: u16 = 1;
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat1Shape {
    value_record_byte_len: usize,
}

impl SinglePosFormat1Shape {
    fn pos_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.pos_format_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn value_format_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + ValueFormat::RAW_BYTE_LEN
    }
    fn value_record_byte_range(&self) -> Range<usize> {
        let start = self.value_format_byte_range().end;
        start..start + self.value_record_byte_len
    }
}

impl TableInfo for SinglePosFormat1 {
    type Info = SinglePosFormat1Shape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<Offset16>();
        let value_format: ValueFormat = cursor.read()?;
        let value_record_byte_len = (value_format.record_byte_len());
        cursor.advance_by(value_record_byte_len);
        cursor.finish(SinglePosFormat1Shape {
            value_record_byte_len,
        })
    }
}

impl<'a> TableRef<'a, SinglePosFormat1> {
    pub fn pos_format(&self) -> u16 {
        let range = self.shape.pos_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn coverage_offset(&self) -> Offset16 {
        let range = self.shape.coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn value_format(&self) -> ValueFormat {
        let range = self.shape.value_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat2;

impl Format<u16> for SinglePosFormat2 {
    const FORMAT: u16 = 2;
}

#[derive(Debug, Clone, Copy)]
pub struct SinglePosFormat2Shape {
    value_records_byte_len: usize,
}

impl SinglePosFormat2Shape {
    fn pos_format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.pos_format_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
    fn value_format_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + ValueFormat::RAW_BYTE_LEN
    }
    fn value_count_byte_range(&self) -> Range<usize> {
        let start = self.value_format_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn value_records_byte_range(&self) -> Range<usize> {
        let start = self.value_count_byte_range().end;
        start..start + self.value_records_byte_len
    }
}

impl TableInfo for SinglePosFormat2 {
    type Info = SinglePosFormat2Shape;
    fn parse<'a>(data: &FontData<'a>) -> Result<TableRef<'a, Self>, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<Offset16>();
        let value_format: ValueFormat = cursor.read()?;
        let value_count: u16 = cursor.read()?;
        let value_records_byte_len = (value_count as usize * value_format.record_byte_len());
        cursor.advance_by(value_records_byte_len);
        cursor.finish(SinglePosFormat2Shape {
            value_records_byte_len,
        })
    }
}

impl<'a> TableRef<'a, SinglePosFormat2> {
    pub fn pos_format(&self) -> u16 {
        let range = self.shape.pos_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn coverage_offset(&self) -> Offset16 {
        let range = self.shape.coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn value_format(&self) -> ValueFormat {
        let range = self.shape.value_format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn value_count(&self) -> u16 {
        let range = self.shape.value_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

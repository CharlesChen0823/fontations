// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

use crate::layout::ClassDef;
use crate::layout::CoverageTable;
use crate::layout::FeatureList;
use crate::layout::FeatureVariations;
use crate::layout::ScriptList;
use font_types::*;

/// [GPOS Version 1.0](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#gpos-header)
pub struct Gpos1_0<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookup_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gpos1_0<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (script_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gpos1_0 {
            major_version,
            minor_version,
            script_list_offset,
            feature_list_offset,
            lookup_list_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gpos1_0<'a> {
    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GPOS table, = 0
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        self.script_list_offset.get()
    }

    pub fn script_list(&self) -> Option<ScriptList> {
        self.script_list_offset().read(self.bytes())
    }

    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        self.feature_list_offset.get()
    }

    pub fn feature_list(&self) -> Option<FeatureList> {
        self.feature_list_offset().read(self.bytes())
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        self.lookup_list_offset.get()
    }

    pub fn lookup_list(&self) -> Option<PositionLookupList> {
        self.lookup_list_offset().read(self.bytes())
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos1_0<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [GPOS Version 1.1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#gpos-header)
pub struct Gpos1_1<'a> {
    major_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    minor_version: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    script_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    lookup_list_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    feature_variations_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset32>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for Gpos1_1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (major_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (minor_version, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (script_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (lookup_list_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (feature_variations_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset32>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = Gpos1_1 {
            major_version,
            minor_version,
            script_list_offset,
            feature_list_offset,
            lookup_list_offset,
            feature_variations_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> Gpos1_1<'a> {
    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        self.major_version.get()
    }

    /// Minor version of the GPOS table, = 1
    pub fn minor_version(&self) -> u16 {
        self.minor_version.get()
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        self.script_list_offset.get()
    }

    pub fn script_list(&self) -> Option<ScriptList> {
        self.script_list_offset().read(self.bytes())
    }

    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        self.feature_list_offset.get()
    }

    pub fn feature_list(&self) -> Option<FeatureList> {
        self.feature_list_offset().read(self.bytes())
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        self.lookup_list_offset.get()
    }

    pub fn lookup_list(&self) -> Option<PositionLookupList> {
        self.lookup_list_offset().read(self.bytes())
    }

    /// Offset to FeatureVariations table, from beginning of GPOS table
    /// (may be NULL)
    pub fn feature_variations_offset(&self) -> Offset32 {
        self.feature_variations_offset.get()
    }

    pub fn feature_variations(&self) -> Option<FeatureVariations> {
        self.feature_variations_offset().read(self.bytes())
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos1_1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

pub enum Gpos<'a> {
    Version1_0(Gpos1_0<'a>),
    Version1_1(Gpos1_1<'a>),
}

impl<'a> font_types::FontRead<'a> for Gpos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        const _: MajorMinor = MajorMinor::VERSION_1_0;
        const _: MajorMinor = MajorMinor::VERSION_1_1;
        let version: BigEndian<MajorMinor> = font_types::FontRead::read(bytes)?;
        match version.get() {
            MajorMinor::VERSION_1_0 => Some(Self::Version1_0(font_types::FontRead::read(bytes)?)),
            MajorMinor::VERSION_1_1 => Some(Self::Version1_1(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(Gpos)
                    );
                }
                None
            }
        }
    }
}

impl<'a> Gpos<'a> {
    pub fn feature_list(&self) -> Option<FeatureList> {
        match self {
            Self::Version1_0(_inner) => _inner.feature_list(),
            Self::Version1_1(_inner) => _inner.feature_list(),
        }
    }

    /// Offset to FeatureList table, from beginning of GPOS table
    pub fn feature_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.feature_list_offset(),
            Self::Version1_1(_inner) => _inner.feature_list_offset(),
        }
    }

    pub fn feature_variations(&self) -> Option<FeatureVariations> {
        match self {
            Self::Version1_0(_inner) => None,
            Self::Version1_1(_inner) => _inner.feature_variations(),
        }
    }

    /// Offset to FeatureVariations table, from beginning of GPOS table
    /// (may be NULL)
    pub fn feature_variations_offset(&self) -> Option<Offset32> {
        match self {
            Self::Version1_0(_inner) => None,
            Self::Version1_1(_inner) => Some(_inner.feature_variations_offset()),
        }
    }

    pub fn lookup_list(&self) -> Option<PositionLookupList> {
        match self {
            Self::Version1_0(_inner) => _inner.lookup_list(),
            Self::Version1_1(_inner) => _inner.lookup_list(),
        }
    }

    /// Offset to LookupList table, from beginning of GPOS table
    pub fn lookup_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.lookup_list_offset(),
            Self::Version1_1(_inner) => _inner.lookup_list_offset(),
        }
    }

    /// Major version of the GPOS table, = 1
    pub fn major_version(&self) -> u16 {
        match self {
            Self::Version1_0(_inner) => _inner.major_version(),
            Self::Version1_1(_inner) => _inner.major_version(),
        }
    }

    /// Minor version of the GPOS table, = 0
    pub fn minor_version(&self) -> u16 {
        match self {
            Self::Version1_0(_inner) => _inner.minor_version(),
            Self::Version1_1(_inner) => _inner.minor_version(),
        }
    }

    pub fn script_list(&self) -> Option<ScriptList> {
        match self {
            Self::Version1_0(_inner) => _inner.script_list(),
            Self::Version1_1(_inner) => _inner.script_list(),
        }
    }

    /// Offset to ScriptList table, from beginning of GPOS table
    pub fn script_list_offset(&self) -> Offset16 {
        match self {
            Self::Version1_0(_inner) => _inner.script_list_offset(),
            Self::Version1_1(_inner) => _inner.script_list_offset(),
        }
    }
}

impl<'a> font_types::OffsetHost<'a> for Gpos<'a> {
    fn bytes(&self) -> &'a [u8] {
        match self {
            Self::Version1_0(_inner) => _inner.bytes(),
            Self::Version1_1(_inner) => _inner.bytes(),
        }
    }
}

bitflags::bitflags! { # [doc = " See [ValueRecord]"] pub struct ValueFormat : u16 { # [doc = " Includes horizontal adjustment for placement"] const X_PLACEMENT = 0x0001 ; # [doc = " Includes vertical adjustment for placement"] const Y_PLACEMENT = 0x0002 ; # [doc = " Includes horizontal adjustment for advance"] const X_ADVANCE = 0x0004 ; # [doc = " Includes vertical adjustment for advance"] const Y_ADVANCE = 0x0008 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal placement"] const X_PLACEMENT_DEVICE = 0x0010 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical placement"] const Y_PLACEMENT_DEVICE = 0x0020 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for horizontal advance"] const X_ADVANCE_DEVICE = 0x0040 ; # [doc = " Includes Device table (non-variable font) / VariationIndex"] # [doc = " table (variable font) for vertical advance"] const Y_ADVANCE_DEVICE = 0x0080 ; } }

impl font_types::Scalar for ValueFormat {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        self.bits().to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::from_bits_truncate(t)
    }
}

pub enum AnchorTable<'a> {
    Format1(AnchorFormat1),
    Format2(AnchorFormat2),
    Format3(AnchorFormat3<'a>),
}

impl<'a> font_types::FontRead<'a> for AnchorTable<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            3 => Some(Self::Format3(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(AnchorTable)
                    );
                }
                None
            }
        }
    }
}

/// [Anchor Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-1-design-units): Design Units
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct AnchorFormat1 {
    /// Format identifier, = 1
    pub anchor_format: BigEndian<u16>,
    /// Horizontal value, in design units
    pub x_coordinate: BigEndian<i16>,
    /// Vertical value, in design units
    pub y_coordinate: BigEndian<i16>,
}

impl AnchorFormat1 {
    /// Format identifier, = 1
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }
}

/// [Anchor Table Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-2-design-units-plus-contour-point): Design Units Plus Contour Point
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct AnchorFormat2 {
    /// Format identifier, = 2
    pub anchor_format: BigEndian<u16>,
    /// Horizontal value, in design units
    pub x_coordinate: BigEndian<i16>,
    /// Vertical value, in design units
    pub y_coordinate: BigEndian<i16>,
    /// Index to glyph contour point
    pub anchor_point: BigEndian<u16>,
}

impl AnchorFormat2 {
    /// Format identifier, = 2
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }

    /// Index to glyph contour point
    pub fn anchor_point(&self) -> u16 {
        self.anchor_point.get()
    }
}

#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct FakeDeviceTable {
    pub version: BigEndian<u16>,
}

impl FakeDeviceTable {
    pub fn version(&self) -> u16 {
        self.version.get()
    }
}

/// [Anchor Table Format 3]()https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-table-format-3-design-units-plus-device-or-variationindex-tables: Design Units Plus Device or VariationIndex Tables
pub struct AnchorFormat3<'a> {
    anchor_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    x_coordinate: zerocopy::LayoutVerified<&'a [u8], BigEndian<i16>>,
    y_coordinate: zerocopy::LayoutVerified<&'a [u8], BigEndian<i16>>,
    x_device_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    y_device_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for AnchorFormat3<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (anchor_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (x_coordinate, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<i16>>::new_unaligned_from_prefix(bytes)?;
        let (y_coordinate, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<i16>>::new_unaligned_from_prefix(bytes)?;
        let (x_device_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (y_device_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = AnchorFormat3 {
            anchor_format,
            x_coordinate,
            y_coordinate,
            x_device_offset,
            y_device_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> AnchorFormat3<'a> {
    /// Format identifier, = 3
    pub fn anchor_format(&self) -> u16 {
        self.anchor_format.get()
    }

    /// Horizontal value, in design units
    pub fn x_coordinate(&self) -> i16 {
        self.x_coordinate.get()
    }

    /// Vertical value, in design units
    pub fn y_coordinate(&self) -> i16 {
        self.y_coordinate.get()
    }

    /// Offset to Device table (non-variable font) / VariationIndex
    /// table (variable font) for X coordinate, from beginning of
    /// Anchor table (may be NULL)
    pub fn x_device_offset(&self) -> Offset16 {
        self.x_device_offset.get()
    }

    pub fn x_device(&self) -> Option<FakeDeviceTable> {
        self.x_device_offset().read(self.bytes())
    }

    /// Offset to Device table (non-variable font) / VariationIndex
    /// table (variable font) for Y coordinate, from beginning of
    /// Anchor table (may be NULL)
    pub fn y_device_offset(&self) -> Offset16 {
        self.y_device_offset.get()
    }

    pub fn y_device(&self) -> Option<FakeDeviceTable> {
        self.y_device_offset().read(self.bytes())
    }
}

impl<'a> font_types::OffsetHost<'a> for AnchorFormat3<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Mark Array Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-array-table)
pub struct MarkArray<'a> {
    mark_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_records: zerocopy::LayoutVerified<&'a [u8], [MarkRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkArray<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (mark_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_mark_count = mark_count.get();
        let (mark_records, bytes) =
            zerocopy::LayoutVerified::<_, [MarkRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_count as usize,
            )?;
        let _bytes = bytes;
        let result = MarkArray {
            mark_count,
            mark_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkArray<'a> {
    /// Number of MarkRecords
    pub fn mark_count(&self) -> u16 {
        self.mark_count.get()
    }

    /// Array of MarkRecords, ordered by corresponding glyphs in the
    /// associated mark Coverage table.
    pub fn mark_records(&self) -> &[MarkRecord] {
        &self.mark_records
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkArray<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkArray]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct MarkRecord {
    /// Class defined for the associated mark.
    pub mark_class: BigEndian<u16>,
    /// Offset to Anchor table, from beginning of MarkArray table.
    pub mark_anchor_offset: BigEndian<Offset16>,
}

impl MarkRecord {
    /// Class defined for the associated mark.
    pub fn mark_class(&self) -> u16 {
        self.mark_class.get()
    }

    /// Offset to Anchor table, from beginning of MarkArray table.
    pub fn mark_anchor_offset(&self) -> Offset16 {
        self.mark_anchor_offset.get()
    }
}

/// [Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable): Single Adjustment Positioning Subtable
pub enum SinglePos<'a> {
    Format1(SinglePosFormat1<'a>),
    Format2(SinglePosFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for SinglePos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(SinglePos)
                    );
                }
                None
            }
        }
    }
}

/// [Single Adjustment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#single-adjustment-positioning-format-1-single-positioning-value): Single Positioning Value
pub struct SinglePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_record: ValueRecord,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SinglePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format = value_format.get();
        let (value_record, bytes) =
            font_types::FontReadWithArgs::read_with_args(bytes.get(..)?, &__resolved_value_format)?;
        let _bytes = bytes;
        let result = SinglePosFormat1 {
            pos_format,
            coverage_offset,
            value_format,
            value_record,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SinglePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of SinglePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Defines the types of data in the ValueRecord.
    pub fn value_format(&self) -> ValueFormat {
        self.value_format.get()
    }

    /// Defines positioning value(s) — applied to all glyphs in the
    /// Coverage table.
    pub fn value_record(&self) -> &ValueRecord {
        &self.value_record
    }
}

impl<'a> font_types::OffsetHost<'a> for SinglePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Single Adjustment Positioning Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#single-adjustment-positioning-format-2-array-of-positioning-values): Array of Positioning Values
pub struct SinglePosFormat2<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    value_records: DynSizedArray<'a, ValueFormat, ValueRecord>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for SinglePosFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format = value_format.get();
        let (value_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_value_count = value_count.get();
        let (value_records, bytes) = {
            let head = bytes.get(
                ..value_record_array_len(__resolved_value_format, __resolved_value_count) as usize,
            )?;
            let (r, _) =
                font_types::FontReadWithArgs::read_with_args(head, &__resolved_value_format)?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = SinglePosFormat2 {
            pos_format,
            coverage_offset,
            value_format,
            value_count,
            value_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> SinglePosFormat2<'a> {
    /// Format identifier: format = 2
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of SinglePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Defines the types of data in the ValueRecords.
    pub fn value_format(&self) -> ValueFormat {
        self.value_format.get()
    }

    /// Number of ValueRecords — must equal glyphCount in the
    /// Coverage table.
    pub fn value_count(&self) -> u16 {
        self.value_count.get()
    }

    /// Array of ValueRecords — positioning values applied to glyphs.
    pub fn value_records(&self) -> &DynSizedArray<'a, ValueFormat, ValueRecord> {
        &self.value_records
    }
}

impl<'a> font_types::OffsetHost<'a> for SinglePosFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// [Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable): Single Adjustment Positioning Subtable
pub enum PairPos<'a> {
    Format1(PairPosFormat1<'a>),
    Format2(PairPosFormat2<'a>),
}

impl<'a> font_types::FontRead<'a> for PairPos<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let version: BigEndian<u16> = font_types::FontRead::read(bytes)?;
        match version.get() {
            1 => Some(Self::Format1(font_types::FontRead::read(bytes)?)),
            2 => Some(Self::Format2(font_types::FontRead::read(bytes)?)),
            _other => {
                #[cfg(feature = "std")]
                {
                    eprintln!(
                        "unknown enum variant {:?} (table {})",
                        version,
                        stringify!(PairPos)
                    );
                }
                None
            }
        }
    }
}

/// [Pair Adjustment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#pair-adjustment-positioning-format-1-adjustments-for-glyph-pairs): Adjustments for Glyph Pairs
pub struct PairPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format1: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_format2: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    pair_set_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    pair_set_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for PairPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format1, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let (value_format2, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let (pair_set_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_pair_set_count = pair_set_count.get();
        let (pair_set_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_pair_set_count as usize,
            )?;
        let _bytes = bytes;
        let result = PairPosFormat1 {
            pos_format,
            coverage_offset,
            value_format1,
            value_format2,
            pair_set_count,
            pair_set_offsets,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> PairPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of PairPos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Defines the types of data in valueRecord1 — for the first
    /// glyph in the pair (may be zero).
    pub fn value_format1(&self) -> ValueFormat {
        self.value_format1.get()
    }

    /// Defines the types of data in valueRecord2 — for the second
    /// glyph in the pair (may be zero).
    pub fn value_format2(&self) -> ValueFormat {
        self.value_format2.get()
    }

    /// Number of PairSet tables
    pub fn pair_set_count(&self) -> u16 {
        self.pair_set_count.get()
    }

    /// Array of offsets to PairSet tables. Offsets are from beginning
    /// of PairPos subtable, ordered by Coverage Index.
    pub fn pair_set_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.pair_set_offsets
    }

    pub fn pair_set(&self) -> impl Iterator<Item = Option<PairSet>> + '_ {
        self.pair_set_offsets().iter().map(|item| {
            item.get().read_with_args::<_, PairSet>(
                self.bytes(),
                &(self.value_format1(), self.value_format2()),
            )
        })
    }
}

impl<'a> font_types::OffsetHost<'a> for PairPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [PairPosFormat1]
pub struct PairSet<'a> {
    pair_value_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    pair_value_records: DynSizedArray<'a, (ValueFormat, ValueFormat), PairValueRecord>,
}

impl<'a> font_types::FontReadWithArgs<'a, (ValueFormat, ValueFormat)> for PairSet<'a> {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_value_format1 = args.0;
        let __resolved_value_format2 = args.1;
        let (pair_value_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_pair_value_count = pair_value_count.get();
        let (pair_value_records, bytes) = {
            let head = bytes.get(
                ..pair_value_record_len(
                    __resolved_pair_value_count,
                    __resolved_value_format1,
                    __resolved_value_format2,
                ) as usize,
            )?;
            let (r, _) = font_types::FontReadWithArgs::read_with_args(
                head,
                &(__resolved_value_format1, __resolved_value_format2),
            )?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = PairSet {
            pair_value_count,
            pair_value_records,
        };
        Some((result, _bytes))
    }
}

impl<'a> PairSet<'a> {
    /// Number of PairValueRecords
    pub fn pair_value_count(&self) -> u16 {
        self.pair_value_count.get()
    }

    /// Array of PairValueRecords, ordered by glyph ID of the second
    /// glyph.
    pub fn pair_value_records(
        &self,
    ) -> &DynSizedArray<'a, (ValueFormat, ValueFormat), PairValueRecord> {
        &self.pair_value_records
    }
}

/// [Pair Adjustment Positioning Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#pair-adjustment-positioning-format-2-class-pair-adjustment): Class Pair Adjustment
pub struct PairPosFormat2<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    value_format1: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    value_format2: zerocopy::LayoutVerified<&'a [u8], BigEndian<ValueFormat>>,
    class_def1_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class_def2_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    class1_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class2_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    class1_records: DynSizedArray<'a, (u16, ValueFormat, ValueFormat), Class1Record<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for PairPosFormat2<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (value_format1, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format1 = value_format1.get();
        let (value_format2, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<ValueFormat>>::new_unaligned_from_prefix(
                bytes,
            )?;
        let __resolved_value_format2 = value_format2.get();
        let (class_def1_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class_def2_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (class1_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class1_count = class1_count.get();
        let (class2_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_class2_count = class2_count.get();
        let (class1_records, bytes) = {
            let head = bytes.get(
                ..class1_record_len(
                    __resolved_class1_count,
                    __resolved_class2_count,
                    __resolved_value_format1,
                    __resolved_value_format2,
                ) as usize,
            )?;
            let (r, _) = font_types::FontReadWithArgs::read_with_args(
                head,
                &(
                    __resolved_class2_count,
                    __resolved_value_format1,
                    __resolved_value_format2,
                ),
            )?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = PairPosFormat2 {
            pos_format,
            coverage_offset,
            value_format1,
            value_format2,
            class_def1_offset,
            class_def2_offset,
            class1_count,
            class2_count,
            class1_records,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> PairPosFormat2<'a> {
    /// Format identifier: format = 2
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of PairPos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// ValueRecord definition — for the first glyph of the pair (may
    /// be zero).
    pub fn value_format1(&self) -> ValueFormat {
        self.value_format1.get()
    }

    /// ValueRecord definition — for the second glyph of the pair
    /// (may be zero).
    pub fn value_format2(&self) -> ValueFormat {
        self.value_format2.get()
    }

    /// Offset to ClassDef table, from beginning of PairPos subtable
    /// — for the first glyph of the pair.
    pub fn class_def1_offset(&self) -> Offset16 {
        self.class_def1_offset.get()
    }

    pub fn class_def1(&self) -> Option<ClassDef> {
        self.class_def1_offset().read(self.bytes())
    }

    /// Offset to ClassDef table, from beginning of PairPos subtable
    /// — for the second glyph of the pair.
    pub fn class_def2_offset(&self) -> Offset16 {
        self.class_def2_offset.get()
    }

    pub fn class_def2(&self) -> Option<ClassDef> {
        self.class_def2_offset().read(self.bytes())
    }

    /// Number of classes in classDef1 table — includes Class 0.
    pub fn class1_count(&self) -> u16 {
        self.class1_count.get()
    }

    /// Number of classes in classDef2 table — includes Class 0.
    pub fn class2_count(&self) -> u16 {
        self.class2_count.get()
    }

    /// Array of Class1 records, ordered by classes in classDef1.
    pub fn class1_records(
        &self,
    ) -> &DynSizedArray<'a, (u16, ValueFormat, ValueFormat), Class1Record<'a>> {
        &self.class1_records
    }
}

impl<'a> font_types::OffsetHost<'a> for PairPosFormat2<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [PairPosFormat2]
pub struct Class1Record<'a> {
    class2_records: DynSizedArray<'a, (ValueFormat, ValueFormat), Class2Record>,
}

impl<'a> font_types::FontReadWithArgs<'a, (u16, ValueFormat, ValueFormat)> for Class1Record<'a> {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(u16, ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_class2_count = args.0;
        let __resolved_value_format1 = args.1;
        let __resolved_value_format2 = args.2;
        let (class2_records, bytes) = {
            let head = bytes.get(
                ..class2_record_len(
                    __resolved_class2_count,
                    __resolved_value_format1,
                    __resolved_value_format2,
                ) as usize,
            )?;
            let (r, _) = font_types::FontReadWithArgs::read_with_args(
                head,
                &(__resolved_value_format1, __resolved_value_format2),
            )?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = Class1Record { class2_records };
        Some((result, _bytes))
    }
}

impl<'a> Class1Record<'a> {
    /// Array of Class2 records, ordered by classes in classDef2.
    pub fn class2_records(&self) -> &DynSizedArray<'a, (ValueFormat, ValueFormat), Class2Record> {
        &self.class2_records
    }
}

/// Part of [PairPosFormat2]
pub struct Class2Record {
    value_record1: ValueRecord,
    value_record2: ValueRecord,
}

impl<'a> font_types::FontReadWithArgs<'a, (ValueFormat, ValueFormat)> for Class2Record {
    fn read_with_args(
        bytes: &'a [u8],
        args: &(ValueFormat, ValueFormat),
    ) -> Option<(Self, &'a [u8])> {
        let __resolved_value_format1 = args.0;
        let __resolved_value_format2 = args.1;
        let (value_record1, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..)?,
            &__resolved_value_format1,
        )?;
        let (value_record2, bytes) = font_types::FontReadWithArgs::read_with_args(
            bytes.get(..)?,
            &__resolved_value_format2,
        )?;
        let _bytes = bytes;
        let result = Class2Record {
            value_record1,
            value_record2,
        };
        Some((result, _bytes))
    }
}

impl Class2Record {
    /// Positioning for first glyph — empty if valueFormat1 = 0.
    pub fn value_record1(&self) -> &ValueRecord {
        &self.value_record1
    }

    /// Positioning for second glyph — empty if valueFormat2 = 0.
    pub fn value_record2(&self) -> &ValueRecord {
        &self.value_record2
    }
}

/// [Cursive Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#cursive-attachment-positioning-format1-cursive-attachment): Cursvie attachment
pub struct CursivePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    entry_exit_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    entry_exit_record: zerocopy::LayoutVerified<&'a [u8], [EntryExitRecord]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for CursivePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (entry_exit_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_entry_exit_count = entry_exit_count.get();
        let (entry_exit_record, bytes) =
            zerocopy::LayoutVerified::<_, [EntryExitRecord]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_entry_exit_count as usize,
            )?;
        let _bytes = bytes;
        let result = CursivePosFormat1 {
            pos_format,
            coverage_offset,
            entry_exit_count,
            entry_exit_record,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> CursivePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Coverage table, from beginning of CursivePos subtable.
    pub fn coverage_offset(&self) -> Offset16 {
        self.coverage_offset.get()
    }

    pub fn coverage(&self) -> Option<CoverageTable> {
        self.coverage_offset().read(self.bytes())
    }

    /// Number of EntryExit records
    pub fn entry_exit_count(&self) -> u16 {
        self.entry_exit_count.get()
    }

    /// Array of EntryExit records, in Coverage index order.
    pub fn entry_exit_record(&self) -> &[EntryExitRecord] {
        &self.entry_exit_record
    }
}

impl<'a> font_types::OffsetHost<'a> for CursivePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [CursivePosFormat1]
#[derive(Clone, Copy, Debug, zerocopy :: FromBytes, zerocopy :: Unaligned)]
#[repr(C)]
pub struct EntryExitRecord {
    /// Offset to entryAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub entry_anchor_offset: BigEndian<Offset16>,
    /// Offset to exitAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub exit_anchor_offset: BigEndian<Offset16>,
}

impl EntryExitRecord {
    /// Offset to entryAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub fn entry_anchor_offset(&self) -> Offset16 {
        self.entry_anchor_offset.get()
    }

    /// Offset to exitAnchor table, from beginning of CursivePos
    /// subtable (may be NULL).
    pub fn exit_anchor_offset(&self) -> Offset16 {
        self.exit_anchor_offset.get()
    }
}

/// [Mark-to-Base Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-base-attachment-positioning-format-1-mark-to-base-attachment-point): Mark-to-base Attachment Point
pub struct MarkBasePosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    base_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    base_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkBasePosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (base_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (base_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkBasePosFormat1 {
            pos_format,
            mark_coverage_offset,
            base_coverage_offset,
            mark_class_count,
            mark_array_offset,
            base_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkBasePosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to markCoverage table, from beginning of MarkBasePos
    /// subtable.
    pub fn mark_coverage_offset(&self) -> Offset16 {
        self.mark_coverage_offset.get()
    }

    pub fn mark_coverage(&self) -> Option<CoverageTable> {
        self.mark_coverage_offset().read(self.bytes())
    }

    /// Offset to baseCoverage table, from beginning of MarkBasePos
    /// subtable.
    pub fn base_coverage_offset(&self) -> Offset16 {
        self.base_coverage_offset.get()
    }

    pub fn base_coverage(&self) -> Option<CoverageTable> {
        self.base_coverage_offset().read(self.bytes())
    }

    /// Number of classes defined for marks
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table, from beginning of MarkBasePos
    /// subtable.
    pub fn mark_array_offset(&self) -> Offset16 {
        self.mark_array_offset.get()
    }

    pub fn mark_array(&self) -> Option<MarkArray> {
        self.mark_array_offset().read(self.bytes())
    }

    /// Offset to BaseArray table, from beginning of MarkBasePos
    /// subtable.
    pub fn base_array_offset(&self) -> Offset16 {
        self.base_array_offset.get()
    }

    pub fn base_array(&self) -> Option<BaseArray> {
        self.base_array_offset()
            .read_with_args::<_, BaseArray>(self.bytes(), &self.mark_class_count())
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkBasePosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkBasePosFormat1]
pub struct BaseArray<'a> {
    base_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    base_records: DynSizedArray<'a, u16, BaseRecord<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for BaseArray<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (base_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_base_count = base_count.get();
        let (base_records, bytes) = {
            let head = bytes.get(
                ..nested_offset_array_len(__resolved_base_count, __resolved_mark_class_count)
                    as usize,
            )?;
            let (r, _) =
                font_types::FontReadWithArgs::read_with_args(head, &__resolved_mark_class_count)?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = BaseArray {
            base_count,
            base_records,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> BaseArray<'a> {
    /// Number of BaseRecords
    pub fn base_count(&self) -> u16 {
        self.base_count.get()
    }

    /// Array of BaseRecords, in order of baseCoverage Index.
    pub fn base_records(&self) -> &DynSizedArray<'a, u16, BaseRecord<'a>> {
        &self.base_records
    }
}

impl<'a> font_types::OffsetHost<'a> for BaseArray<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [BaseArray]
pub struct BaseRecord<'a> {
    base_anchor_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for BaseRecord<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let (base_anchor_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_class_count as usize,
            )?;
        let _bytes = bytes;
        let result = BaseRecord {
            base_anchor_offsets,
        };
        Some((result, _bytes))
    }
}

impl<'a> BaseRecord<'a> {
    /// Array of offsets (one per mark class) to Anchor tables. Offsets
    /// are from beginning of BaseArray table, ordered by class
    /// (offsets may be NULL).
    pub fn base_anchor_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.base_anchor_offsets
    }
}

/// [Mark-to-Ligature Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-ligature-attachment-positioning-format-1-mark-to-ligature-attachment): Mark-to-Ligature Attachment
pub struct MarkLigPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    ligature_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    ligature_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkLigPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (ligature_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (ligature_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkLigPosFormat1 {
            pos_format,
            mark_coverage_offset,
            ligature_coverage_offset,
            mark_class_count,
            mark_array_offset,
            ligature_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkLigPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to markCoverage table, from beginning of MarkLigPos
    /// subtable.
    pub fn mark_coverage_offset(&self) -> Offset16 {
        self.mark_coverage_offset.get()
    }

    pub fn mark_coverage(&self) -> Option<CoverageTable> {
        self.mark_coverage_offset().read(self.bytes())
    }

    /// Offset to ligatureCoverage table, from beginning of MarkLigPos
    /// subtable.
    pub fn ligature_coverage_offset(&self) -> Offset16 {
        self.ligature_coverage_offset.get()
    }

    pub fn ligature_coverage(&self) -> Option<CoverageTable> {
        self.ligature_coverage_offset().read(self.bytes())
    }

    /// Number of defined mark classes
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table, from beginning of MarkLigPos
    /// subtable.
    pub fn mark_array_offset(&self) -> Offset16 {
        self.mark_array_offset.get()
    }

    pub fn mark_array(&self) -> Option<MarkArray> {
        self.mark_array_offset().read(self.bytes())
    }

    /// Offset to LigatureArray table, from beginning of MarkLigPos
    /// subtable.
    pub fn ligature_array_offset(&self) -> Offset16 {
        self.ligature_array_offset.get()
    }

    pub fn ligature_array(&self) -> Option<LigatureArray> {
        self.ligature_array_offset()
            .read_with_args::<_, LigatureArray>(self.bytes(), &self.mark_class_count())
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkLigPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct LigatureArray<'a> {
    ligature_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    ligature_attach_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for LigatureArray<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (ligature_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_ligature_count = ligature_count.get();
        let (ligature_attach_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_ligature_count as usize,
            )?;
        let _bytes = bytes;
        let result = LigatureArray {
            ligature_count,
            ligature_attach_offsets,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> LigatureArray<'a> {
    /// Number of LigatureAttach table offsets
    pub fn ligature_count(&self) -> u16 {
        self.ligature_count.get()
    }

    /// Array of offsets to LigatureAttach tables. Offsets are from
    /// beginning of LigatureArray table, ordered by ligatureCoverage
    /// index.
    pub fn ligature_attach_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.ligature_attach_offsets
    }
}

impl<'a> font_types::OffsetHost<'a> for LigatureArray<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct LigatureAttach<'a> {
    component_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    component_records: DynSizedArray<'a, u16, ComponentRecord<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for LigatureAttach<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (component_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_component_count = component_count.get();
        let (component_records, bytes) = {
            let head = bytes.get(
                ..nested_offset_array_len(__resolved_component_count, __resolved_mark_class_count)
                    as usize,
            )?;
            let (r, _) =
                font_types::FontReadWithArgs::read_with_args(head, &__resolved_mark_class_count)?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = LigatureAttach {
            component_count,
            component_records,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> LigatureAttach<'a> {
    /// Number of ComponentRecords in this ligature
    pub fn component_count(&self) -> u16 {
        self.component_count.get()
    }

    /// Array of Component records, ordered in writing direction.
    pub fn component_records(&self) -> &DynSizedArray<'a, u16, ComponentRecord<'a>> {
        &self.component_records
    }
}

impl<'a> font_types::OffsetHost<'a> for LigatureAttach<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkLigPosFormat1]
pub struct ComponentRecord<'a> {
    ligature_anchor_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for ComponentRecord<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let (ligature_anchor_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_class_count as usize,
            )?;
        let _bytes = bytes;
        let result = ComponentRecord {
            ligature_anchor_offsets,
        };
        Some((result, _bytes))
    }
}

impl<'a> ComponentRecord<'a> {
    /// Array of offsets (one per class) to Anchor tables. Offsets are
    /// from beginning of LigatureAttach table, ordered by class
    /// (offsets may be NULL).
    pub fn ligature_anchor_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.ligature_anchor_offsets
    }
}

/// [Mark-to-Mark Attachment Positioning Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-to-mark-attachment-positioning-format-1-mark-to-mark-attachment): Mark-to-Mark Attachment
pub struct MarkMarkPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark1_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark2_coverage_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark_class_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark1_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    mark2_array_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset16>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for MarkMarkPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark1_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark2_coverage_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark_class_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (mark1_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let (mark2_array_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset16>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = MarkMarkPosFormat1 {
            pos_format,
            mark1_coverage_offset,
            mark2_coverage_offset,
            mark_class_count,
            mark1_array_offset,
            mark2_array_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> MarkMarkPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Offset to Combining Mark Coverage table, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark1_coverage_offset(&self) -> Offset16 {
        self.mark1_coverage_offset.get()
    }

    pub fn mark1_coverage(&self) -> Option<CoverageTable> {
        self.mark1_coverage_offset().read(self.bytes())
    }

    /// Offset to Base Mark Coverage table, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark2_coverage_offset(&self) -> Offset16 {
        self.mark2_coverage_offset.get()
    }

    pub fn mark2_coverage(&self) -> Option<CoverageTable> {
        self.mark2_coverage_offset().read(self.bytes())
    }

    /// Number of Combining Mark classes defined
    pub fn mark_class_count(&self) -> u16 {
        self.mark_class_count.get()
    }

    /// Offset to MarkArray table for mark1, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark1_array_offset(&self) -> Offset16 {
        self.mark1_array_offset.get()
    }

    pub fn mark1_array(&self) -> Option<MarkArray> {
        self.mark1_array_offset().read(self.bytes())
    }

    /// Offset to Mark2Array table for mark2, from beginning of
    /// MarkMarkPos subtable.
    pub fn mark2_array_offset(&self) -> Offset16 {
        self.mark2_array_offset.get()
    }

    pub fn mark2_array(&self) -> Option<Mark2Array> {
        self.mark2_array_offset()
            .read_with_args::<_, Mark2Array>(self.bytes(), &self.mark_class_count())
    }
}

impl<'a> font_types::OffsetHost<'a> for MarkMarkPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkMarkPosFormat1]Class2Record
pub struct Mark2Array<'a> {
    mark2_count: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    mark2_records: DynSizedArray<'a, u16, Mark2Record<'a>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for Mark2Array<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let offset_bytes = bytes;
        let (mark2_count, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let __resolved_mark2_count = mark2_count.get();
        let (mark2_records, bytes) = {
            let head = bytes.get(
                ..nested_offset_array_len(__resolved_mark2_count, __resolved_mark_class_count)
                    as usize,
            )?;
            let (r, _) =
                font_types::FontReadWithArgs::read_with_args(head, &__resolved_mark_class_count)?;
            (r, bytes.get(head.len()..).unwrap_or_default())
        };
        let _bytes = bytes;
        let result = Mark2Array {
            mark2_count,
            mark2_records,
            offset_bytes,
        };
        Some((result, _bytes))
    }
}

impl<'a> Mark2Array<'a> {
    /// Number of Mark2 records
    pub fn mark2_count(&self) -> u16 {
        self.mark2_count.get()
    }

    /// Array of Mark2Records, in Coverage order.
    pub fn mark2_records(&self) -> &DynSizedArray<'a, u16, Mark2Record<'a>> {
        &self.mark2_records
    }
}

impl<'a> font_types::OffsetHost<'a> for Mark2Array<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

/// Part of [MarkMarkPosFormat1]
pub struct Mark2Record<'a> {
    mark2_anchor_offsets: zerocopy::LayoutVerified<&'a [u8], [BigEndian<Offset16>]>,
}

impl<'a> font_types::FontReadWithArgs<'a, u16> for Mark2Record<'a> {
    fn read_with_args(bytes: &'a [u8], mark_class_count: &u16) -> Option<(Self, &'a [u8])> {
        let __resolved_mark_class_count = *mark_class_count;
        let (mark2_anchor_offsets, bytes) =
            zerocopy::LayoutVerified::<_, [BigEndian<Offset16>]>::new_slice_unaligned_from_prefix(
                bytes,
                __resolved_mark_class_count as usize,
            )?;
        let _bytes = bytes;
        let result = Mark2Record {
            mark2_anchor_offsets,
        };
        Some((result, _bytes))
    }
}

impl<'a> Mark2Record<'a> {
    /// Array of offsets (one per class) to Anchor tables. Offsets are
    /// from beginning of Mark2Array table, in class order (offsets may
    /// be NULL).
    pub fn mark2_anchor_offsets(&self) -> &[BigEndian<Offset16>] {
        &self.mark2_anchor_offsets
    }
}

/// [Extension Positioning Subtable Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#extension-positioning-subtable-format-1)
pub struct ExtensionPosFormat1<'a> {
    pos_format: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    extension_lookup_type: zerocopy::LayoutVerified<&'a [u8], BigEndian<u16>>,
    extension_offset: zerocopy::LayoutVerified<&'a [u8], BigEndian<Offset32>>,
    offset_bytes: &'a [u8],
}

impl<'a> font_types::FontRead<'a> for ExtensionPosFormat1<'a> {
    fn read(bytes: &'a [u8]) -> Option<Self> {
        let offset_bytes = bytes;
        let (pos_format, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (extension_lookup_type, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<u16>>::new_unaligned_from_prefix(bytes)?;
        let (extension_offset, bytes) =
            zerocopy::LayoutVerified::<_, BigEndian<Offset32>>::new_unaligned_from_prefix(bytes)?;
        let _bytes = bytes;
        let result = ExtensionPosFormat1 {
            pos_format,
            extension_lookup_type,
            extension_offset,
            offset_bytes,
        };
        Some(result)
    }
}

impl<'a> ExtensionPosFormat1<'a> {
    /// Format identifier: format = 1
    pub fn pos_format(&self) -> u16 {
        self.pos_format.get()
    }

    /// Lookup type of subtable referenced by extensionOffset (i.e. the
    /// extension subtable).
    pub fn extension_lookup_type(&self) -> u16 {
        self.extension_lookup_type.get()
    }

    /// Offset to the extension subtable, of lookup type
    /// extensionLookupType, relative to the start of the
    /// ExtensionPosFormat1 subtable.
    pub fn extension_offset(&self) -> Offset32 {
        self.extension_offset.get()
    }
}

impl<'a> font_types::OffsetHost<'a> for ExtensionPosFormat1<'a> {
    fn bytes(&self) -> &'a [u8] {
        self.offset_bytes
    }
}

fn value_record_array_len(format: ValueFormat, count: u16) -> usize {
    count as usize * value_record_len(format)
}

fn value_record_len(format: ValueFormat) -> usize {
    format.bits().count_ones() as usize * std::mem::size_of::<u16>()
}

fn pair_value_record_len(count: u16, format1: ValueFormat, format2: ValueFormat) -> usize {
    std::mem::size_of::<u16>()
        + format1.record_byte_len()
        + format2.record_byte_len() * count as usize
}

fn class1_record_len(
    class1_count: u16,
    class2_count: u16,
    format1: ValueFormat,
    format2: ValueFormat,
) -> usize {
    class2_record_len(class2_count, format1, format2) * class1_count as usize
}

fn class2_record_len(class2_count: u16, format1: ValueFormat, format2: ValueFormat) -> usize {
    (format1.record_byte_len() + format2.record_byte_len()) * class2_count as usize
}

fn nested_offset_array_len(array_len: u16, mark_class_count: u16) -> usize {
    std::mem::size_of::<u16>() * mark_class_count as usize * array_len as usize
}

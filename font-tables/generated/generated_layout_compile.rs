// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::compile::*;

#[allow(unused_imports)]
use font_types::*;
fn plus_one(inp: usize) -> u16 {
    inp.saturating_add(1).try_into().unwrap()
}

#[derive(Debug, PartialEq)]
pub struct ScriptList {
    pub script_records: Vec<ScriptRecord>,
}

impl ToOwnedObj for super::ScriptList<'_> {
    type Owned = ScriptList;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ScriptList {
            script_records: self
                .script_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ScriptList<'_> {}

impl FontWrite for ScriptList {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.script_records.len())
            .unwrap()
            .write_into(writer);
        self.script_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ScriptRecord {
    pub script_tag: Tag,
    pub script_offset: OffsetMarker<Offset16, Script>,
}

impl ToOwnedObj for super::ScriptRecord {
    type Owned = ScriptRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ScriptRecord {
            script_tag: self.script_tag(),
            script_offset: OffsetMarker::new_maybe_null(
                self.script_offset()
                    .read::<super::Script>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl FontWrite for ScriptRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.script_tag.write_into(writer);
        self.script_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct Script {
    pub default_lang_sys_offset: NullableOffsetMarker<Offset16, LangSys>,
    pub lang_sys_records: Vec<LangSysRecord>,
}

impl ToOwnedObj for super::Script<'_> {
    type Owned = Script;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(Script {
            default_lang_sys_offset: NullableOffsetMarker::new(
                self.default_lang_sys_offset()
                    .read::<super::LangSys>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lang_sys_records: self
                .lang_sys_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::Script<'_> {}

impl FontWrite for Script {
    fn write_into(&self, writer: &mut TableWriter) {
        self.default_lang_sys_offset.write_into(writer);
        u16::try_from(self.lang_sys_records.len())
            .unwrap()
            .write_into(writer);
        self.lang_sys_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct LangSysRecord {
    pub lang_sys_tag: Tag,
    pub lang_sys_offset: OffsetMarker<Offset16, LangSys>,
}

impl ToOwnedObj for super::LangSysRecord {
    type Owned = LangSysRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(LangSysRecord {
            lang_sys_tag: self.lang_sys_tag(),
            lang_sys_offset: OffsetMarker::new_maybe_null(
                self.lang_sys_offset()
                    .read::<super::LangSys>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl FontWrite for LangSysRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.lang_sys_tag.write_into(writer);
        self.lang_sys_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct LangSys {
    pub required_feature_index: u16,
    pub feature_indices: Vec<u16>,
}

impl ToOwnedObj for super::LangSys<'_> {
    type Owned = LangSys;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(LangSys {
            required_feature_index: self.required_feature_index(),
            feature_indices: self
                .feature_indices()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for LangSys {
    fn write_into(&self, writer: &mut TableWriter) {
        let lookup_order_offset: u16 = 0;
        lookup_order_offset.write_into(writer);
        self.required_feature_index.write_into(writer);
        u16::try_from(self.feature_indices.len())
            .unwrap()
            .write_into(writer);
        self.feature_indices.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureList {
    pub feature_records: Vec<FeatureRecord>,
}

impl ToOwnedObj for super::FeatureList<'_> {
    type Owned = FeatureList;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(FeatureList {
            feature_records: self.feature_records_to_owned()?,
        })
    }
}

impl ToOwnedTable for super::FeatureList<'_> {}

impl FontWrite for FeatureList {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.feature_records.len())
            .unwrap()
            .write_into(writer);
        self.feature_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureRecord {
    pub feature_tag: Tag,
    pub feature_offset: OffsetMarker<Offset16, Feature>,
}

impl FontWrite for FeatureRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.feature_tag.write_into(writer);
        self.feature_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct Feature {
    pub feature_params_offset: NullableOffsetMarker<Offset16, FeatureParams>,
    pub lookup_list_indices: Vec<u16>,
}

impl FontWrite for Feature {
    fn write_into(&self, writer: &mut TableWriter) {
        self.feature_params_offset.write_into(writer);
        u16::try_from(self.lookup_list_indices.len())
            .unwrap()
            .write_into(writer);
        self.lookup_list_indices.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct CoverageFormat1 {
    pub glyph_array: Vec<u16>,
}

impl ToOwnedObj for super::CoverageFormat1<'_> {
    type Owned = CoverageFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(CoverageFormat1 {
            glyph_array: self
                .glyph_array()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for CoverageFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let coverage_format: u16 = 1;
        coverage_format.write_into(writer);
        u16::try_from(self.glyph_array.len())
            .unwrap()
            .write_into(writer);
        self.glyph_array.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct CoverageFormat2 {
    pub range_records: Vec<RangeRecord>,
}

impl ToOwnedObj for super::CoverageFormat2<'_> {
    type Owned = CoverageFormat2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(CoverageFormat2 {
            range_records: self
                .range_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for CoverageFormat2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let coverage_format: u16 = 2;
        coverage_format.write_into(writer);
        u16::try_from(self.range_records.len())
            .unwrap()
            .write_into(writer);
        self.range_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct RangeRecord {
    pub start_glyph_id: u16,
    pub end_glyph_id: u16,
    pub start_coverage_index: u16,
}

impl ToOwnedObj for super::RangeRecord {
    type Owned = RangeRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(RangeRecord {
            start_glyph_id: self.start_glyph_id(),
            end_glyph_id: self.end_glyph_id(),
            start_coverage_index: self.start_coverage_index(),
        })
    }
}

impl FontWrite for RangeRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.start_glyph_id.write_into(writer);
        self.end_glyph_id.write_into(writer);
        self.start_coverage_index.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum CoverageTable {
    Format1(CoverageFormat1),
    Format2(CoverageFormat2),
}

impl ToOwnedObj for super::CoverageTable<'_> {
    type Owned = CoverageTable;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::CoverageTable::Format1(item) => {
                CoverageTable::Format1(item.to_owned_obj(offset_data)?)
            }
            super::CoverageTable::Format2(item) => {
                CoverageTable::Format2(item.to_owned_obj(offset_data)?)
            }
        })
    }
}

impl FontWrite for CoverageTable {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Format1(item) => item.write_into(writer),
            Self::Format2(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct ClassDefFormat1 {
    pub start_glyph_id: u16,
    pub class_value_array: Vec<u16>,
}

impl ToOwnedObj for super::ClassDefFormat1<'_> {
    type Owned = ClassDefFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ClassDefFormat1 {
            start_glyph_id: self.start_glyph_id(),
            class_value_array: self
                .class_value_array()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for ClassDefFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let class_format: u16 = 1;
        class_format.write_into(writer);
        self.start_glyph_id.write_into(writer);
        u16::try_from(self.class_value_array.len())
            .unwrap()
            .write_into(writer);
        self.class_value_array.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ClassDefFormat2 {
    pub class_range_records: Vec<ClassRangeRecord>,
}

impl ToOwnedObj for super::ClassDefFormat2<'_> {
    type Owned = ClassDefFormat2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ClassDefFormat2 {
            class_range_records: self
                .class_range_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for ClassDefFormat2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let class_format: u16 = 2;
        class_format.write_into(writer);
        u16::try_from(self.class_range_records.len())
            .unwrap()
            .write_into(writer);
        self.class_range_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ClassRangeRecord {
    pub start_glyph_id: u16,
    pub end_glyph_id: u16,
    pub class: u16,
}

impl ToOwnedObj for super::ClassRangeRecord {
    type Owned = ClassRangeRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ClassRangeRecord {
            start_glyph_id: self.start_glyph_id(),
            end_glyph_id: self.end_glyph_id(),
            class: self.class(),
        })
    }
}

impl FontWrite for ClassRangeRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.start_glyph_id.write_into(writer);
        self.end_glyph_id.write_into(writer);
        self.class.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum ClassDef {
    Format1(ClassDefFormat1),
    Format2(ClassDefFormat2),
}

impl ToOwnedObj for super::ClassDef<'_> {
    type Owned = ClassDef;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::ClassDef::Format1(item) => ClassDef::Format1(item.to_owned_obj(offset_data)?),
            super::ClassDef::Format2(item) => ClassDef::Format2(item.to_owned_obj(offset_data)?),
        })
    }
}

impl FontWrite for ClassDef {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Format1(item) => item.write_into(writer),
            Self::Format2(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceLookupRecord {
    pub sequence_index: u16,
    pub lookup_list_index: u16,
}

impl ToOwnedObj for super::SequenceLookupRecord {
    type Owned = SequenceLookupRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(SequenceLookupRecord {
            sequence_index: self.sequence_index(),
            lookup_list_index: self.lookup_list_index(),
        })
    }
}

impl FontWrite for SequenceLookupRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.sequence_index.write_into(writer);
        self.lookup_list_index.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceContextFormat1 {
    pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
    pub seq_rule_set_offsets: Vec<NullableOffsetMarker<Offset16, SequenceRuleSet>>,
}

impl ToOwnedObj for super::SequenceContextFormat1<'_> {
    type Owned = SequenceContextFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(SequenceContextFormat1 {
            coverage_offset: OffsetMarker::new_maybe_null(
                self.coverage_offset()
                    .read::<super::CoverageTable>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            seq_rule_set_offsets: self
                .seq_rule_set_offsets()
                .iter()
                .map(|item| {
                    Some(NullableOffsetMarker::new(
                        item.get()
                            .read::<super::SequenceRuleSet>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::SequenceContextFormat1<'_> {}

impl FontWrite for SequenceContextFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 1;
        format.write_into(writer);
        self.coverage_offset.write_into(writer);
        u16::try_from(self.seq_rule_set_offsets.len())
            .unwrap()
            .write_into(writer);
        self.seq_rule_set_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceRuleSet {
    pub seq_rule_offsets: Vec<OffsetMarker<Offset16, SequenceRule>>,
}

impl ToOwnedObj for super::SequenceRuleSet<'_> {
    type Owned = SequenceRuleSet;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(SequenceRuleSet {
            seq_rule_offsets: self
                .seq_rule_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::SequenceRule>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::SequenceRuleSet<'_> {}

impl FontWrite for SequenceRuleSet {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.seq_rule_offsets.len())
            .unwrap()
            .write_into(writer);
        self.seq_rule_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceRule {
    pub input_sequence: Vec<u16>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::SequenceRule<'_> {
    type Owned = SequenceRule;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(SequenceRule {
            input_sequence: self
                .input_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for SequenceRule {
    fn write_into(&self, writer: &mut TableWriter) {
        let glyph_count: u16 = plus_one(self.input_sequence.len());
        glyph_count.write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.input_sequence.write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceContextFormat2 {
    pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
    pub class_def_offset: OffsetMarker<Offset16, ClassDef>,
    pub class_seq_rule_set_offsets: Vec<NullableOffsetMarker<Offset16, ClassSequenceRuleSet>>,
}

impl ToOwnedObj for super::SequenceContextFormat2<'_> {
    type Owned = SequenceContextFormat2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(SequenceContextFormat2 {
            coverage_offset: OffsetMarker::new_maybe_null(
                self.coverage_offset()
                    .read::<super::CoverageTable>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            class_def_offset: OffsetMarker::new_maybe_null(
                self.class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            class_seq_rule_set_offsets: self
                .class_seq_rule_set_offsets()
                .iter()
                .map(|item| {
                    Some(NullableOffsetMarker::new(
                        item.get()
                            .read::<super::ClassSequenceRuleSet>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::SequenceContextFormat2<'_> {}

impl FontWrite for SequenceContextFormat2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 2;
        format.write_into(writer);
        self.coverage_offset.write_into(writer);
        self.class_def_offset.write_into(writer);
        u16::try_from(self.class_seq_rule_set_offsets.len())
            .unwrap()
            .write_into(writer);
        self.class_seq_rule_set_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ClassSequenceRuleSet {
    pub class_seq_rule_offsets: Vec<OffsetMarker<Offset16, ClassSequenceRule>>,
}

impl ToOwnedObj for super::ClassSequenceRuleSet<'_> {
    type Owned = ClassSequenceRuleSet;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ClassSequenceRuleSet {
            class_seq_rule_offsets: self
                .class_seq_rule_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::ClassSequenceRule>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ClassSequenceRuleSet<'_> {}

impl FontWrite for ClassSequenceRuleSet {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.class_seq_rule_offsets.len())
            .unwrap()
            .write_into(writer);
        self.class_seq_rule_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ClassSequenceRule {
    pub input_sequence: Vec<u16>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::ClassSequenceRule<'_> {
    type Owned = ClassSequenceRule;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ClassSequenceRule {
            input_sequence: self
                .input_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for ClassSequenceRule {
    fn write_into(&self, writer: &mut TableWriter) {
        let glyph_count: u16 = plus_one(self.input_sequence.len());
        glyph_count.write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.input_sequence.write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SequenceContextFormat3 {
    pub coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::SequenceContextFormat3<'_> {
    type Owned = SequenceContextFormat3;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(SequenceContextFormat3 {
            coverage_offsets: self
                .coverage_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CoverageTable>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::SequenceContextFormat3<'_> {}

impl FontWrite for SequenceContextFormat3 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 3;
        format.write_into(writer);
        u16::try_from(self.coverage_offsets.len())
            .unwrap()
            .write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.coverage_offsets.write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum SequenceContext {
    Format1(SequenceContextFormat1),
    Format2(SequenceContextFormat2),
    Format3(SequenceContextFormat3),
}

impl ToOwnedObj for super::SequenceContext<'_> {
    type Owned = SequenceContext;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::SequenceContext::Format1(item) => {
                SequenceContext::Format1(item.to_owned_obj(offset_data)?)
            }
            super::SequenceContext::Format2(item) => {
                SequenceContext::Format2(item.to_owned_obj(offset_data)?)
            }
            super::SequenceContext::Format3(item) => {
                SequenceContext::Format3(item.to_owned_obj(offset_data)?)
            }
        })
    }
}

impl ToOwnedTable for super::SequenceContext<'_> {}

impl FontWrite for SequenceContext {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Format1(item) => item.write_into(writer),
            Self::Format2(item) => item.write_into(writer),
            Self::Format3(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedSequenceContextFormat1 {
    pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
    pub chained_seq_rule_set_offsets: Vec<NullableOffsetMarker<Offset16, ChainedSequenceRuleSet>>,
}

impl ToOwnedObj for super::ChainedSequenceContextFormat1<'_> {
    type Owned = ChainedSequenceContextFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ChainedSequenceContextFormat1 {
            coverage_offset: OffsetMarker::new_maybe_null(
                self.coverage_offset()
                    .read::<super::CoverageTable>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            chained_seq_rule_set_offsets: self
                .chained_seq_rule_set_offsets()
                .iter()
                .map(|item| {
                    Some(NullableOffsetMarker::new(
                        item.get()
                            .read::<super::ChainedSequenceRuleSet>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ChainedSequenceContextFormat1<'_> {}

impl FontWrite for ChainedSequenceContextFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 1;
        format.write_into(writer);
        self.coverage_offset.write_into(writer);
        u16::try_from(self.chained_seq_rule_set_offsets.len())
            .unwrap()
            .write_into(writer);
        self.chained_seq_rule_set_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedSequenceRuleSet {
    pub chained_seq_rule_offsets: Vec<OffsetMarker<Offset16, ChainedSequenceRule>>,
}

impl ToOwnedObj for super::ChainedSequenceRuleSet<'_> {
    type Owned = ChainedSequenceRuleSet;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ChainedSequenceRuleSet {
            chained_seq_rule_offsets: self
                .chained_seq_rule_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::ChainedSequenceRule>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ChainedSequenceRuleSet<'_> {}

impl FontWrite for ChainedSequenceRuleSet {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.chained_seq_rule_offsets.len())
            .unwrap()
            .write_into(writer);
        self.chained_seq_rule_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedSequenceRule {
    pub backtrack_sequence: Vec<u16>,
    pub input_sequence: Vec<u16>,
    pub lookahead_sequence: Vec<u16>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::ChainedSequenceRule<'_> {
    type Owned = ChainedSequenceRule;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ChainedSequenceRule {
            backtrack_sequence: self
                .backtrack_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            input_sequence: self
                .input_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            lookahead_sequence: self
                .lookahead_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for ChainedSequenceRule {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.backtrack_sequence.len())
            .unwrap()
            .write_into(writer);
        self.backtrack_sequence.write_into(writer);
        let input_glyph_count: u16 = plus_one(self.input_sequence.len());
        input_glyph_count.write_into(writer);
        self.input_sequence.write_into(writer);
        u16::try_from(self.lookahead_sequence.len())
            .unwrap()
            .write_into(writer);
        self.lookahead_sequence.write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedSequenceContextFormat2 {
    pub coverage_offset: OffsetMarker<Offset16, CoverageTable>,
    pub backtrack_class_def_offset: OffsetMarker<Offset16, ClassDef>,
    pub input_class_def_offset: OffsetMarker<Offset16, ClassDef>,
    pub lookahead_class_def_offset: OffsetMarker<Offset16, ClassDef>,
    pub chained_class_seq_rule_set_offsets:
        Vec<NullableOffsetMarker<Offset16, ChainedClassSequenceRuleSet>>,
}

impl ToOwnedObj for super::ChainedSequenceContextFormat2<'_> {
    type Owned = ChainedSequenceContextFormat2;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ChainedSequenceContextFormat2 {
            coverage_offset: OffsetMarker::new_maybe_null(
                self.coverage_offset()
                    .read::<super::CoverageTable>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            backtrack_class_def_offset: OffsetMarker::new_maybe_null(
                self.backtrack_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            input_class_def_offset: OffsetMarker::new_maybe_null(
                self.input_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            lookahead_class_def_offset: OffsetMarker::new_maybe_null(
                self.lookahead_class_def_offset()
                    .read::<super::ClassDef>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            chained_class_seq_rule_set_offsets: self
                .chained_class_seq_rule_set_offsets()
                .iter()
                .map(|item| {
                    Some(NullableOffsetMarker::new(
                        item.get()
                            .read::<super::ChainedClassSequenceRuleSet>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ChainedSequenceContextFormat2<'_> {}

impl FontWrite for ChainedSequenceContextFormat2 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 2;
        format.write_into(writer);
        self.coverage_offset.write_into(writer);
        self.backtrack_class_def_offset.write_into(writer);
        self.input_class_def_offset.write_into(writer);
        self.lookahead_class_def_offset.write_into(writer);
        u16::try_from(self.chained_class_seq_rule_set_offsets.len())
            .unwrap()
            .write_into(writer);
        self.chained_class_seq_rule_set_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedClassSequenceRuleSet {
    pub chained_class_seq_rule_offsets: Vec<OffsetMarker<Offset16, ChainedClassSequenceRule>>,
}

impl ToOwnedObj for super::ChainedClassSequenceRuleSet<'_> {
    type Owned = ChainedClassSequenceRuleSet;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ChainedClassSequenceRuleSet {
            chained_class_seq_rule_offsets: self
                .chained_class_seq_rule_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::ChainedClassSequenceRule>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ChainedClassSequenceRuleSet<'_> {}

impl FontWrite for ChainedClassSequenceRuleSet {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.chained_class_seq_rule_offsets.len())
            .unwrap()
            .write_into(writer);
        self.chained_class_seq_rule_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedClassSequenceRule {
    pub backtrack_sequence: Vec<u16>,
    pub input_sequence: Vec<u16>,
    pub lookahead_sequence: Vec<u16>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::ChainedClassSequenceRule<'_> {
    type Owned = ChainedClassSequenceRule;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ChainedClassSequenceRule {
            backtrack_sequence: self
                .backtrack_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            input_sequence: self
                .input_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            lookahead_sequence: self
                .lookahead_sequence()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for ChainedClassSequenceRule {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.backtrack_sequence.len())
            .unwrap()
            .write_into(writer);
        self.backtrack_sequence.write_into(writer);
        let input_glyph_count: u16 = plus_one(self.input_sequence.len());
        input_glyph_count.write_into(writer);
        self.input_sequence.write_into(writer);
        u16::try_from(self.lookahead_sequence.len())
            .unwrap()
            .write_into(writer);
        self.lookahead_sequence.write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ChainedSequenceContextFormat3 {
    pub backtrack_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
    pub input_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
    pub lookahead_coverage_offsets: Vec<OffsetMarker<Offset16, CoverageTable>>,
    pub seq_lookup_records: Vec<SequenceLookupRecord>,
}

impl ToOwnedObj for super::ChainedSequenceContextFormat3<'_> {
    type Owned = ChainedSequenceContextFormat3;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ChainedSequenceContextFormat3 {
            backtrack_coverage_offsets: self
                .backtrack_coverage_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CoverageTable>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
            input_coverage_offsets: self
                .input_coverage_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CoverageTable>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
            lookahead_coverage_offsets: self
                .lookahead_coverage_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::CoverageTable>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
            seq_lookup_records: self
                .seq_lookup_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ChainedSequenceContextFormat3<'_> {}

impl FontWrite for ChainedSequenceContextFormat3 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 3;
        format.write_into(writer);
        u16::try_from(self.backtrack_coverage_offsets.len())
            .unwrap()
            .write_into(writer);
        self.backtrack_coverage_offsets.write_into(writer);
        u16::try_from(self.input_coverage_offsets.len())
            .unwrap()
            .write_into(writer);
        self.input_coverage_offsets.write_into(writer);
        u16::try_from(self.lookahead_coverage_offsets.len())
            .unwrap()
            .write_into(writer);
        self.lookahead_coverage_offsets.write_into(writer);
        u16::try_from(self.seq_lookup_records.len())
            .unwrap()
            .write_into(writer);
        self.seq_lookup_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub enum ChainedSequenceContext {
    Format1(ChainedSequenceContextFormat1),
    Format2(ChainedSequenceContextFormat2),
    Format3(ChainedSequenceContextFormat3),
}

impl ToOwnedObj for super::ChainedSequenceContext<'_> {
    type Owned = ChainedSequenceContext;
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(match self {
            super::ChainedSequenceContext::Format1(item) => {
                ChainedSequenceContext::Format1(item.to_owned_obj(offset_data)?)
            }
            super::ChainedSequenceContext::Format2(item) => {
                ChainedSequenceContext::Format2(item.to_owned_obj(offset_data)?)
            }
            super::ChainedSequenceContext::Format3(item) => {
                ChainedSequenceContext::Format3(item.to_owned_obj(offset_data)?)
            }
        })
    }
}

impl ToOwnedTable for super::ChainedSequenceContext<'_> {}

impl FontWrite for ChainedSequenceContext {
    fn write_into(&self, writer: &mut TableWriter) {
        match self {
            Self::Format1(item) => item.write_into(writer),
            Self::Format2(item) => item.write_into(writer),
            Self::Format3(item) => item.write_into(writer),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct Device {
    pub start_size: u16,
    pub end_size: u16,
    pub delta_format: u16,
    pub delta_value: Vec<u16>,
}

impl ToOwnedObj for super::Device<'_> {
    type Owned = Device;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(Device {
            start_size: self.start_size(),
            end_size: self.end_size(),
            delta_format: self.delta_format(),
            delta_value: self
                .delta_value()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for Device {
    fn write_into(&self, writer: &mut TableWriter) {
        self.start_size.write_into(writer);
        self.end_size.write_into(writer);
        self.delta_format.write_into(writer);
        self.delta_value.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct VariationIndex {
    pub delta_set_outer_index: u16,
    pub delta_set_inner_index: u16,
    pub delta_format: u16,
}

impl ToOwnedObj for super::VariationIndex {
    type Owned = VariationIndex;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(VariationIndex {
            delta_set_outer_index: self.delta_set_outer_index(),
            delta_set_inner_index: self.delta_set_inner_index(),
            delta_format: self.delta_format(),
        })
    }
}

impl FontWrite for VariationIndex {
    fn write_into(&self, writer: &mut TableWriter) {
        self.delta_set_outer_index.write_into(writer);
        self.delta_set_inner_index.write_into(writer);
        self.delta_format.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureVariations {
    pub feature_variation_records: Vec<FeatureVariationRecord>,
}

impl ToOwnedObj for super::FeatureVariations<'_> {
    type Owned = FeatureVariations;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(FeatureVariations {
            feature_variation_records: self
                .feature_variation_records()
                .iter()
                .map(|item| item.to_owned_obj(offset_data))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::FeatureVariations<'_> {}

impl FontWrite for FeatureVariations {
    fn write_into(&self, writer: &mut TableWriter) {
        let major_version: u16 = 1;
        major_version.write_into(writer);
        let minor_version: u16 = 0;
        minor_version.write_into(writer);
        u32::try_from(self.feature_variation_records.len())
            .unwrap()
            .write_into(writer);
        self.feature_variation_records.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureVariationRecord {
    pub condition_set_offset: OffsetMarker<Offset32, ConditionSet>,
    pub feature_table_substitution_offset: OffsetMarker<Offset32, FeatureTableSubstitution>,
}

impl ToOwnedObj for super::FeatureVariationRecord {
    type Owned = FeatureVariationRecord;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(FeatureVariationRecord {
            condition_set_offset: OffsetMarker::new_maybe_null(
                self.condition_set_offset()
                    .read::<super::ConditionSet>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
            feature_table_substitution_offset: OffsetMarker::new_maybe_null(
                self.feature_table_substitution_offset()
                    .read::<super::FeatureTableSubstitution>(offset_data)
                    .and_then(|obj| obj.to_owned_obj(offset_data)),
            ),
        })
    }
}

impl FontWrite for FeatureVariationRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.condition_set_offset.write_into(writer);
        self.feature_table_substitution_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ConditionSet {
    pub condition_offsets: Vec<OffsetMarker<Offset32, ConditionFormat1>>,
}

impl ToOwnedObj for super::ConditionSet<'_> {
    type Owned = ConditionSet;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(ConditionSet {
            condition_offsets: self
                .condition_offsets()
                .iter()
                .map(|item| {
                    Some(OffsetMarker::new_maybe_null(
                        item.get()
                            .read::<super::ConditionFormat1>(offset_data)
                            .and_then(|obj| obj.to_owned_obj(offset_data)),
                    ))
                })
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl ToOwnedTable for super::ConditionSet<'_> {}

impl FontWrite for ConditionSet {
    fn write_into(&self, writer: &mut TableWriter) {
        u16::try_from(self.condition_offsets.len())
            .unwrap()
            .write_into(writer);
        self.condition_offsets.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct ConditionFormat1 {
    pub axis_index: u16,
    pub filter_range_min_value: F2Dot14,
    pub filter_range_max_value: F2Dot14,
}

impl ToOwnedObj for super::ConditionFormat1 {
    type Owned = ConditionFormat1;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(ConditionFormat1 {
            axis_index: self.axis_index(),
            filter_range_min_value: self.filter_range_min_value(),
            filter_range_max_value: self.filter_range_max_value(),
        })
    }
}

impl FontWrite for ConditionFormat1 {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 1;
        format.write_into(writer);
        self.axis_index.write_into(writer);
        self.filter_range_min_value.write_into(writer);
        self.filter_range_max_value.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureTableSubstitution {
    pub substitutions: Vec<FeatureTableSubstitutionRecord>,
}

impl ToOwnedObj for super::FeatureTableSubstitution<'_> {
    type Owned = FeatureTableSubstitution;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        let offset_data = self.bytes();
        Some(FeatureTableSubstitution {
            substitutions: self.substitutions_to_owned()?,
        })
    }
}

impl ToOwnedTable for super::FeatureTableSubstitution<'_> {}

impl FontWrite for FeatureTableSubstitution {
    fn write_into(&self, writer: &mut TableWriter) {
        let major_version: u16 = 1;
        major_version.write_into(writer);
        let minor_version: u16 = 0;
        minor_version.write_into(writer);
        u16::try_from(self.substitutions.len())
            .unwrap()
            .write_into(writer);
        self.substitutions.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct FeatureTableSubstitutionRecord {
    pub feature_index: u16,
    pub alternate_feature_offset: OffsetMarker<Offset32, Feature>,
}

impl FontWrite for FeatureTableSubstitutionRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.feature_index.write_into(writer);
        self.alternate_feature_offset.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct SizeParams {
    pub design_size: u16,
    pub identifier: u16,
    pub name_entry: u16,
    pub range_start: u16,
    pub range_end: u16,
}

impl ToOwnedObj for super::SizeParams {
    type Owned = SizeParams;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(SizeParams {
            design_size: self.design_size(),
            identifier: self.identifier(),
            name_entry: self.name_entry(),
            range_start: self.range_start(),
            range_end: self.range_end(),
        })
    }
}

impl FontWrite for SizeParams {
    fn write_into(&self, writer: &mut TableWriter) {
        self.design_size.write_into(writer);
        self.identifier.write_into(writer);
        self.name_entry.write_into(writer);
        self.range_start.write_into(writer);
        self.range_end.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct StylisticSetParams {
    pub ui_name_id: u16,
}

impl ToOwnedObj for super::StylisticSetParams {
    type Owned = StylisticSetParams;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(StylisticSetParams {
            ui_name_id: self.ui_name_id(),
        })
    }
}

impl FontWrite for StylisticSetParams {
    fn write_into(&self, writer: &mut TableWriter) {
        let version: u16 = 0;
        version.write_into(writer);
        self.ui_name_id.write_into(writer);
    }
}

#[derive(Debug, PartialEq)]
pub struct CharacterVariantParams {
    pub feat_ui_label_name_id: u16,
    pub feat_ui_tooltip_text_name_id: u16,
    pub sample_text_name_id: u16,
    pub num_named_parameters: u16,
    pub first_param_ui_label_name_id: u16,
    pub character: Vec<Uint24>,
}

impl ToOwnedObj for super::CharacterVariantParams<'_> {
    type Owned = CharacterVariantParams;

    #[allow(unused_variables)]
    fn to_owned_obj(&self, offset_data: &[u8]) -> Option<Self::Owned> {
        Some(CharacterVariantParams {
            feat_ui_label_name_id: self.feat_ui_label_name_id(),
            feat_ui_tooltip_text_name_id: self.feat_ui_tooltip_text_name_id(),
            sample_text_name_id: self.sample_text_name_id(),
            num_named_parameters: self.num_named_parameters(),
            first_param_ui_label_name_id: self.first_param_ui_label_name_id(),
            character: self
                .character()
                .iter()
                .map(|item| Some(item.get()))
                .collect::<Option<Vec<_>>>()?,
        })
    }
}

impl FontWrite for CharacterVariantParams {
    fn write_into(&self, writer: &mut TableWriter) {
        let format: u16 = 0;
        format.write_into(writer);
        self.feat_ui_label_name_id.write_into(writer);
        self.feat_ui_tooltip_text_name_id.write_into(writer);
        self.sample_text_name_id.write_into(writer);
        self.num_named_parameters.write_into(writer);
        self.first_param_ui_label_name_id.write_into(writer);
        u16::try_from(self.character.len())
            .unwrap()
            .write_into(writer);
        self.character.write_into(writer);
    }
}
